{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"IronHacks Hack for innovation to solve global challenges. The IronHacks framework will solve your problem of where to start with documentation, by providing a basic explanation of how to do it easily. Background IronHacks brings together a virtual hacking community who participate in high-energy IronHacks challenges. The IronHacks platform offers participants a no setup workspace and many powerful features. Participants get access to a Juypter Lab, BIG datasets, dashboards, tutorials so that they can excel in data exploration, prediction and visualization. Features During an iterative multiphase process, the competing participants have access to tutorials, standardized libraries and packages, and virtual help sessions. After each phase, submissions are evaluated within a few hours or days with the help of machine intelligence and human experts. Real-time and targeted feedback accelerate learning and facilitate participants in hacking complex problems. Challenges - Easy access to past, current, and future challenges Workspace - A workspace that integrates to Jupyter Lab and Big Query that allows you to hack in the cloud with no set-up time and costs Feedback - A dashboard with real-time ratings about your submissions as well as access to your peer\u2019s solutions. Impact Since 2015, more than 1000 participants have hacked in parallel virtually around the globe gaining valuable experience in coding as well as work for the chance to win internships, Amazon gift cards, cool swag, and certificates. In addition to the participation and learning, IronHacks provides the opportunity to do research on open innovation contest processes. Innovation Participants developed novel and useful open data solutions in an interactive environment. The platform\u2019s features helped them continuously improve their submissions while learning from real-time feedback and others participating in the hack. Globalization The virtual setting of hacking has emerged at Purdue and beyond. Participants come from the US, Colombia, and China. Virtual setting encourages a more diverse audience. Research The scientific team at Purdue generated new knowledge and technologies on the implications of machine-enabled feedback and transparency on participants\u2019 productivity and innovation performance Authors Research Center for Open Digital Innovation Contribute Issue Tracker: github.com/ironhacks/ironhacks-app/issues Source Code: github.com/ironhacks/ironhacks-app Support If you are having technical issues, the best place to direct questions is the through the public issue tracker. To get in touch directly you can reach the team at: opendigital@purdue.edu IronHacks is an initiative of the Research Center for Open Digital Innovation (RCODI). It is financially supported by the National Science Foundation (Award #1462044). License The project is licensed under the GNU General Public License v3.0 by Research Center for Open Digital Innovation (RCODI).","title":"IronHacks"},{"location":"#ironhacks","text":"Hack for innovation to solve global challenges. The IronHacks framework will solve your problem of where to start with documentation, by providing a basic explanation of how to do it easily.","title":"IronHacks"},{"location":"#background","text":"IronHacks brings together a virtual hacking community who participate in high-energy IronHacks challenges. The IronHacks platform offers participants a no setup workspace and many powerful features. Participants get access to a Juypter Lab, BIG datasets, dashboards, tutorials so that they can excel in data exploration, prediction and visualization.","title":"Background"},{"location":"#features","text":"During an iterative multiphase process, the competing participants have access to tutorials, standardized libraries and packages, and virtual help sessions. After each phase, submissions are evaluated within a few hours or days with the help of machine intelligence and human experts. Real-time and targeted feedback accelerate learning and facilitate participants in hacking complex problems. Challenges - Easy access to past, current, and future challenges Workspace - A workspace that integrates to Jupyter Lab and Big Query that allows you to hack in the cloud with no set-up time and costs Feedback - A dashboard with real-time ratings about your submissions as well as access to your peer\u2019s solutions.","title":"Features"},{"location":"#impact","text":"Since 2015, more than 1000 participants have hacked in parallel virtually around the globe gaining valuable experience in coding as well as work for the chance to win internships, Amazon gift cards, cool swag, and certificates. In addition to the participation and learning, IronHacks provides the opportunity to do research on open innovation contest processes. Innovation Participants developed novel and useful open data solutions in an interactive environment. The platform\u2019s features helped them continuously improve their submissions while learning from real-time feedback and others participating in the hack. Globalization The virtual setting of hacking has emerged at Purdue and beyond. Participants come from the US, Colombia, and China. Virtual setting encourages a more diverse audience. Research The scientific team at Purdue generated new knowledge and technologies on the implications of machine-enabled feedback and transparency on participants\u2019 productivity and innovation performance","title":"Impact"},{"location":"#authors","text":"Research Center for Open Digital Innovation","title":"Authors"},{"location":"#contribute","text":"Issue Tracker: github.com/ironhacks/ironhacks-app/issues Source Code: github.com/ironhacks/ironhacks-app","title":"Contribute"},{"location":"#support","text":"If you are having technical issues, the best place to direct questions is the through the public issue tracker. To get in touch directly you can reach the team at: opendigital@purdue.edu IronHacks is an initiative of the Research Center for Open Digital Innovation (RCODI). It is financially supported by the National Science Foundation (Award #1462044).","title":"Support"},{"location":"#license","text":"The project is licensed under the GNU General Public License v3.0 by Research Center for Open Digital Innovation (RCODI).","title":"License"},{"location":"App-Client/functions/","text":"App Config Work Flow and Functionality Being a Bloggify application, the application configuration is kept in a file: bloggify.js . This contains (see the inline comments): const conf = require(\"bloggify-config\"); // Set the right MongoDB URI (depending on the environment). const DB_URI = process.env.MONGODB_URI if (!DB_URI) { console.error(\">>>> Please provide the MongoDB URI. Set the MONGODB_URI environment variable.\"); } // Application metadata module.exports = conf({ title: \"IronHacks\", description: \"Hack for inovation and join the open data movement.\", // The production domain domain: \"http://www.ironhacks.com\", // Core plugins (which are initialized before the others) corePlugins: [\"bloggify-mongoose\"], // Application plugins plugins: [ \"bloggify-sendgrid\", \"bloggify-custom-assets\", \"bloggify-github-login\" ], // The application router router: \"bloggify-flexible-router\", // We do not have a blog page, so we do not need a Bloggify viewer at all viewer: null, // Plugins configuration config: { // Custom application assets \"bloggify-custom-assets\": { styles: [\"app/assets/stylesheets/index.css\"], server: [\"app/server/index.js\"] }, // The application router \"bloggify-flexible-router\": { controllers_dir: \"app/controllers\", routes_dir: \"app/routes\", error_pages: { 404: \"404.ajs\", 500: \"500.ajs\", bad_csrf: \"422.ajs\" } }, // Login with GitHub \"bloggify-github-login\": { githubClient: process.env.GITHUB_CLIENT, githubSecret: process.env.GITHUB_SECRET }, // Connect to the MongoDB database \"bloggify-mongoose\": { db: DB_URI, models_dir: \"app/models\" }, // Send emails \"bloggify-sendgrid\": { key: process.env.SENDGRID_KEY } } }, { cms_methods: false, server: { session: { storeOptions: { url: DB_URI } } } }); Routes The way how this Bloggify application is structured is explained below. The app directory contains the application files The application routes (urls) are: GET / GET /404 GET /500 GET|POST /admin GET /countdown GET|POST /logout GET|POST /new GET|POST /register GET /login GET /scores GET /search GET /quizzes GET|POST /posts/topicId-_slug/ POST /posts/topicId-_slug/comments POST /posts/topicId-_slug/delete GET|POST /posts/topicId-_slug/edit POST /posts/topicId-_slug/toggle-vote GET|POST /users/_user/edit GET /users/_user The GET method means that we fetch information from the server, while the POST means we post information to the server side. The routes may have associated controllers which are located in the app/controllers directory.","title":"Functions"},{"location":"App-Client/functions/#app-config","text":"Work Flow and Functionality Being a Bloggify application, the application configuration is kept in a file: bloggify.js . This contains (see the inline comments): const conf = require(\"bloggify-config\"); // Set the right MongoDB URI (depending on the environment). const DB_URI = process.env.MONGODB_URI if (!DB_URI) { console.error(\">>>> Please provide the MongoDB URI. Set the MONGODB_URI environment variable.\"); } // Application metadata module.exports = conf({ title: \"IronHacks\", description: \"Hack for inovation and join the open data movement.\", // The production domain domain: \"http://www.ironhacks.com\", // Core plugins (which are initialized before the others) corePlugins: [\"bloggify-mongoose\"], // Application plugins plugins: [ \"bloggify-sendgrid\", \"bloggify-custom-assets\", \"bloggify-github-login\" ], // The application router router: \"bloggify-flexible-router\", // We do not have a blog page, so we do not need a Bloggify viewer at all viewer: null, // Plugins configuration config: { // Custom application assets \"bloggify-custom-assets\": { styles: [\"app/assets/stylesheets/index.css\"], server: [\"app/server/index.js\"] }, // The application router \"bloggify-flexible-router\": { controllers_dir: \"app/controllers\", routes_dir: \"app/routes\", error_pages: { 404: \"404.ajs\", 500: \"500.ajs\", bad_csrf: \"422.ajs\" } }, // Login with GitHub \"bloggify-github-login\": { githubClient: process.env.GITHUB_CLIENT, githubSecret: process.env.GITHUB_SECRET }, // Connect to the MongoDB database \"bloggify-mongoose\": { db: DB_URI, models_dir: \"app/models\" }, // Send emails \"bloggify-sendgrid\": { key: process.env.SENDGRID_KEY } } }, { cms_methods: false, server: { session: { storeOptions: { url: DB_URI } } } });","title":"App Config"},{"location":"App-Client/functions/#routes","text":"The way how this Bloggify application is structured is explained below. The app directory contains the application files The application routes (urls) are: GET / GET /404 GET /500 GET|POST /admin GET /countdown GET|POST /logout GET|POST /new GET|POST /register GET /login GET /scores GET /search GET /quizzes GET|POST /posts/topicId-_slug/ POST /posts/topicId-_slug/comments POST /posts/topicId-_slug/delete GET|POST /posts/topicId-_slug/edit POST /posts/topicId-_slug/toggle-vote GET|POST /users/_user/edit GET /users/_user The GET method means that we fetch information from the server, while the POST means we post information to the server side. The routes may have associated controllers which are located in the app/controllers directory.","title":"Routes"},{"location":"App-Client/install/","text":"Requirements node.js mongoDB Setup Clone the repo rcodi/the-ironhacks-platform git clone git@github.com:RCODI/the-ironhacks-platform.git cd the-ironhacks-platform Install the dependencies: npm install --save-dev Start MongoDB: mongod # or sudo mongod Configuration Before starting the app, you will have to create a file named .env , containing: GITHUB_CLIENT=... GITHUB_SECRET=... SENDGRID_KEY=... MONGODB_URI=mongodb://localhost/purdue_ironhacks You can get the GitHub keys after creating a GitHub application. Do not share these with anyone. Setting up the dev environment You must have installed node.js on your local machine. We assume you already have a firebase project up with the platform The first thing you must do is clone this repository to your local machine and install all the npm packages: git clone https://github.com/RCODI/the-ironhacks-platform.git cd the-ironhacks-platform npm i Now you can start the local server via npm start: npm start","title":"Install"},{"location":"App-Client/install/#requirements","text":"node.js mongoDB","title":"Requirements"},{"location":"App-Client/install/#setup","text":"Clone the repo rcodi/the-ironhacks-platform git clone git@github.com:RCODI/the-ironhacks-platform.git cd the-ironhacks-platform Install the dependencies: npm install --save-dev Start MongoDB: mongod # or sudo mongod","title":"Setup"},{"location":"App-Client/install/#configuration","text":"Before starting the app, you will have to create a file named .env , containing: GITHUB_CLIENT=... GITHUB_SECRET=... SENDGRID_KEY=... MONGODB_URI=mongodb://localhost/purdue_ironhacks You can get the GitHub keys after creating a GitHub application. Do not share these with anyone.","title":"Configuration"},{"location":"App-Client/install/#setting-up-the-dev-environment","text":"You must have installed node.js on your local machine. We assume you already have a firebase project up with the platform The first thing you must do is clone this repository to your local machine and install all the npm packages: git clone https://github.com/RCODI/the-ironhacks-platform.git cd the-ironhacks-platform npm i Now you can start the local server via npm start: npm start","title":"Setting up the dev environment"},{"location":"App-Client/overview/","text":"Preparation The Ironhacks Platform (the platform) use the following firebase services: Authentication Cloud Firestore Storage Hosting Cloud Functions Firebase Auth UI We assume you are familiarized with all these services, how they work, and how to code using them. If you are not familiarized with them please check the Firebase documentation. The platform also use the following frameworks/third party libraries: React react-router-dom Styled-components react-codemirror2 Bootstrap Deprecated - we are removing this library in future versions. If you are going to update the repo, don\u2019t use it. Moment-js react-moment react-day-picker react-mde sweetalert2 react-treebeard We assume you are familiarized with all these librarires, how they work, and how to code using them. If you are not familiarized with them please check the documentation of each one. Project structure The platform is a follow the react-create-app structure: ./ .gitignore firebase.json package.json readme.md public/ All the standard react-create-app files source/ img/ Global images js/ source files and entry point. We will get into details on the contents below.","title":"Preparation"},{"location":"App-Client/overview/#preparation","text":"The Ironhacks Platform (the platform) use the following firebase services: Authentication Cloud Firestore Storage Hosting Cloud Functions Firebase Auth UI We assume you are familiarized with all these services, how they work, and how to code using them. If you are not familiarized with them please check the Firebase documentation. The platform also use the following frameworks/third party libraries: React react-router-dom Styled-components react-codemirror2 Bootstrap Deprecated - we are removing this library in future versions. If you are going to update the repo, don\u2019t use it. Moment-js react-moment react-day-picker react-mde sweetalert2 react-treebeard We assume you are familiarized with all these librarires, how they work, and how to code using them. If you are not familiarized with them please check the documentation of each one.","title":"Preparation"},{"location":"App-Client/overview/#project-structure","text":"The platform is a follow the react-create-app structure: ./ .gitignore firebase.json package.json readme.md public/ All the standard react-create-app files source/ img/ Global images js/ source files and entry point. We will get into details on the contents below.","title":"Project structure"},{"location":"App-Client/usage/","text":"Starting the application Start the app in dev mode: npm run start:dev Make yourself an admin, by passing YOUR GitHub username (the username of the account you use to sign in for the first time): ADMIN_USERNAME=<your-github-username> npm run start:dev For example: ADMIN_USERNAME=hackpurdue npm run start:dev Note : The very first start takes up to 30 seconds because there is no existing cache. After the cache is created, the next application starts will be much faster (1-3 seconds). Deploy When deployed to Heroku, the application url is https://<app-name>.herokuapp.com (unless it\u2019s using a custom domain). Note: When using a free dyno, it\u2019s working fine, but with some limitations: it\u2019s slower it\u2019s going to sleep if it\u2019s innactive for a certain period of time. it has bandwidth limits, but pretty liberal The app configuration is stored in the bloggify.js file. Make sure that the heroku remote exists (run git remote -v for that). If it doesn\u2019t exist, run: heroku git:remote ironhackplatform Commit all the changes and then run the following command: sh npm run deploy =============== Forum structure =============== You may specify the number of forums that you would like to have under the admin interface. ===================== Qualtrix Integration ===================== All the quizzes created on the Qualtrics platform have a snippet of JavaScript which stores the user data in the response (as known as Embedded data ). We store the user_email and the user_id which are sent in the url. The code in the Qualtrics quizzes is set in the last block, last question (which may happen to be an empty question, used for tracking): This approach is being used for all the quizzes: the sign up survey and the other technical quizzes. =============================== Login and Registration Process =============================== When the user is not authenticated, the main page displays two buttons: a login button and a Sign up button. When the login button is clicked, the /login url is opened. The login url redirects to the GitHub authentication workflow (OAuth2) where the user should accept access of our GitHub app in their GitHub account. The difference between the Sign in and Sign up buttons is that for the sign in, we assume that the user already has an account, therefore we make the redirection to GitHub APIs and authenticate them with their GitHub account. In case they do not have an account on the site, they will have to choose the hack type after the GitHub authentication. In Sign up case we will assume that the user doesn\u2019t have an account yet, therefore we ask them to choose the hack type and only then the GitHub authentication is made. Still, if an existing user clicks the Sign up button, they will log in into their account anyways. This is the authentication workflow: In the controllers/register.js file, we create a new user or authenticate an existing user. For the first-time users, we display the selection of the hack type: Purdue, Bogota and Platzi, and then redirect to the survey. At this moment, we start a session on the server side, but we don\u2019t write any data in the users\u2019 database yet. After the user completes the survey, they are redirected back, and the user account is created. To redirect the users to the survey, we send the Location header from the server to the client. Additional data is added in the url parameters to track the user: email : The email of the user user_id : The user id redirect_to : The redirection url where they will arrive after answering the survey. Using a JavaScript snippet in the survey page we store the email and the user id in the survey answer and we detect when the survey is done and redirect the users back to the app. When they finish the survey, they are redirected to the main app and the account is created. When creating a user account, we do not assign a hack_id to the user but we wait until the contest is started. The hack_id is a number based on which we create multiple forums inside of the same hack type. The range can be configured in the admin dashboard. If the user is already registered, they are authenticated based on the existing data. The hack_id values are assigned either when the user signs up (if the contest is already started) or when the contest starts. The default value for hack_id is null . This is changed automatically when the contest starts. The algorithm which assigns the hack ids is designed to create groups of an equal number of users. Specifically, the user will join in the hack id with the fewest users at that moment. The database query is: find how many users we have in each hack id, for a given hack type. Then, join the current user in the hack id with the fewest users. function generateGetHackId(hType, name) { return cb => { User.model.aggregate([{ $match: { \"profile.hack_id\": { $ne: null }, \"profile.hack_type\": name } }, { $group: { _id: \"$profile.hack_id\", total: { $sum: 1 } } }], (err, docs) => { if (err) { return cb(0); } const ids = Array(hType.subforums_count + 1).fill(0); docs.forEach(c => { ids[c._id] = c.total; }); let minId = 0; let min = ids[minId]; ids.forEach((count, index) => { if (count < min) { minId = index; min = ids[minId]; } }); cb(minId); }); }; } forEach(HACK_TYPES, (c, name) => { c.getHackId = generateGetHackId(c, name); }); The function which assigns the hack id values to the users is in the HackTypes controller ( app/controllers/HackTypes.js ). This function receives as input a hack type object and groups the users inside of the hack type. const assignHackIdsToUsers = hType => { const usersCursor = User.model.find({ \"profile.hack_id\": null, \"profile.hack_type\": hType.name }).cursor(); usersCursor.on(\"data\", cDoc => { usersCursor.pause(); hType.getHackId(uHackId => { User.update({ _id: cDoc._id }, { profile: { hack_id: uHackId } }, (err, data) => { if (err) { Bloggify.log(err); } usersCursor.resume(); }); }); }); usersCursor.on(\"error\", err => { Bloggify.log(err); }); usersCursor.on(\"end\", cDoc => { Bloggify.log(`Grouped the studends from ${hType.name}.`); }); }; The function above is called when the countdown finishes, being triggered by a scheduler: const setScheduleForHackType = name => { if (name.name) { name = name.name; } let hackTypeObj = HACK_TYPES[name]; if (hackTypeObj.startSchedule) { hackTypeObj.startSchedule.cancel(); } hackTypeObj.startSchedule = schedule.scheduleJob(hackTypeObj.start_date, () => { assignHackIdsToUsers(hackTypeObj); }); }; Or, it may be triggered when we make changes in the admin dashboard, changing the start of the contest. if (new Date() > thisHackType.start_date) { if (thisHackType.startSchedule) { thisHackType.startSchedule.cancel(); } assignHackIdsToUsers(thisHackType); } else { setScheduleForHackType(thisHackType); } To catch the save event, we add a hook using the addHook method defined by the bloggify-mongoose plugin. Settings.model.addHook(\"post\", \"save\", update); ======== Quizzes ======== The quizzes page displays the quizzes that can be taken by the user. The user may answer the same quiz multiple times. In the view file ( app/routes/quizzes.ajs ) we have the part which renders the links to each quiz: <% include(\"../views/header\", { title: \"Quizzes\" }) %> <% include(\"../views/container/start\") %> <h1>Quizzes</h1> <% quizzes.forEach(function (quiz) { %> <a class=\"btn\" href=\"<%= quiz.url %>\"><%= quiz.label %></a> <% }); %> <% include(\"../views/container/end\") %> <% include(\"../views/footer\") %> The data associated with this view is storred in the controller ( app/controllers/quizzes.js )\u2013see below. The user can click the generated link which contains information about the user (the email address and the user id)\u2013which are storred in the Qualtrics quiz responses as embedded data, and also the redirect url. When the user finishes the quiz, they are redirected back the application, on the /quizzes page and the application marks the quiz complete internally. Even the quiz was completed, the user can take it again. const Bloggify = require(\"bloggify\") , Session = require(\"./Session\") , User = require(\"./User\") , findValue = require(\"find-value\") ; // Define the quizzes list const quizzes = [ [\"d3.js\", \"https://purdue.qualtrics.com/jfe/form/SV_71xEzp5vQ7rC817\", \"d3\"] , [\"HTML & CSS\", \"https://purdue.qualtrics.com/jfe/form/SV_do6Sc9VJsAMmOih\", \"html_css\"] , [\"JavaScript & jQuery\", \"https://purdue.qualtrics.com/jfe/form/SV_b8zyxX8wozQfNul\", \"javascript_jquery\"] ]; // Map the quizzes labels to the data const validQuizzes = {}; quizzes.forEach(c => { validQuizzes[c[2]] = c; }); module.exports = (lien, cb) => { const user = Session.getUser(lien); if (!user) { return lien.redirect(\"/\"); } // Set the quiz complete const completed = lien.query.markComplete; if (completed && validQuizzes[completed]) { return User.update({ _id: user._id }, { profile: { surveys: { [completed]: { ended_at: new Date() } } } }, (err, _user) => { lien.redirect(\"/quizzes\"); }) } // Generate the redirect links const completedSurveys = findValue(user, \"profile.surveys\") || {}; const userQuizzes = quizzes.map(c => { const redirectTo = encodeURIComponent(`${Bloggify.options.metadata.domain}/quizzes?markComplete=${c[2]}`); return { label: c[0] , url: `${c[1]}?redirect_to=${redirectTo}&user_email=${user.email}&user_id=${user._id}` , is_complete: !!completedSurveys[c[2]] }; }); // Send the quizzes array to the view cb(null, { quizzes: userQuizzes }); }; ======== Search ======== On the search page ( /search ) we can search for content which appears either in the post data or in the comments. The view associated with this page is storred in the app/routes/search.ajs and it looks like this: <% include(\"../views/header\", { title: \"Search\" }) %> <% include(\"../views/container/start\") %> <h1>Search</h1> <div class=\"search-form-wrapper\"> <% include(\"../views/search-form\") %> </div> <% if (f(\"results\")) { %> <p class=\"search-results-text\">Search results for <em>\u2018<%= lien.query.search %>\u2019</em></p> <div class=\"search-results\"> <% if (results.length) { %> <% results.forEach(function (cResult) { %> <div class=\"seach-result-item\"> <h2> <a href=\"<%= cResult.url %>\"> <%= cResult.title %> </a> </h2> </div> <% }) %> <% } else { %> <div class=\"no-search-results\"> There are no results. Maybe try a different query. </div> <% } %> </div> <% } %> <% include(\"../views/container/end\") %> <% include(\"../views/footer\") %> This file requires the search-form which appears in the app/views/search-form.ajs file, representing the search form itself: <form> <input type=\"text\" name=\"search\" value=\"<%= lien.query.search || \"\" %>\" placeholder=\"Search for something...\" /> </form> When the user submits the query, the ?search=<query> querystring parameter is added in the url, triggering the search functionality in the controller (located in app/controllers/search.js ). To increase the search results accuracy we used the internal MongoDB text search indexes like this: we created text indexes for the topic title and content and comment content, using the text: true in the model configuration: app/models/Topic.js : module.exports = { ... title: { type: String, text: true }, ... body: { type: String, text: true }, ... }; app/models/Comment.js : module.exports = { ... body: { type: String, text: true }, ... }; Note : The admin users will see the search results from all the forums, while the simple users will see the search results from the forum they belong to. The controller which takes care of searching looks like this: const Session = require(\"./Session\") , Topic = require(\"./Topic\") , Comment = require(\"./Comment\") ; module.exports = (lien, cb) => { const user = Session.getUser(lien); if (!user) { return lien.redirect(\"/\"); } const isAdmin = Session.isAdmin(user); // Perform the search query if (lien.query.search) { // Use the $text index to search const filters = { $text: { $search: lien.query.search } }; let results = {}; // Search in the topics and comments Promise.all([ Topic.model.find(filters) , Comment.model.find(filters) ]).then(data => { results.topics = data[0]; results.comments = data[1].map(c => c.toObject()); return Promise.all(results.comments.map(cComment => { return Topic.model.findOne({ _id: cComment.topic }); })); }).then(topics => { let uniqueTopics = {}; results.topics.concat(topics).forEach(c => { if (!c) { return; } // Let the admin see all the posts/comments in all the forums if (!isAdmin) { if (c.metadata.hack_type !== user.profile.hack_type || c.metadata.hack_id !== user.profile.hack_id) { return; } } uniqueTopics[c._id] = c; c.url = Topic.getUrl(c); }); cb(null, { results: Object.keys(uniqueTopics).map(k => uniqueTopics[k]) }); }).catch(e => { cb(e); }); } else { cb(); } }; ========== Posts Page ========== For authenticated users, we display the posts on the first page, ordered by the date, but the sticky posts are always the first ones. Only the admin users can make create sticky posts (or edit a post and make it sticky). Here, the users from a specific forum can see and upvote the posts from the same forum. They can click on the post urls and post comments. ===================== Single Posts Page ===================== The single post pages are accessible by authenticated users only. They display the post title, body, votes and comments. In case somebody comments, the comments are updated in real-time, the votes too. When a user opens a topic page, we collect stats about that event: actor : the user id who clicked the button topic_id : the topic id phase : the phase of the project created_at : the timestamp ===================== Posting a New Topic ===================== By accessing the /new endpoint, one can post a topic in their forum. They have to write the title and the topic content. The topic content can be styled with Markdown specific styles (bold, italic etc). ======================== Display Page Manipulated ======================== We display the scores of the users, on the /scores page. The users see the anonymous name of the users in the table. The displayed items in the table are shuffled each time. If in the admin interface the scores are not provided, the scores collumns will not appear in the scores. In a similar way it happens for the urls: if we don\u2019t enter the urls, the urls collumns will not appear in the scores page. When the user clicks on the View scores button, we collect stats: actor : the user id who clicked the button hacker_id : the user from the table which was clicked phase : the phase of the project created_at : the timestamp Similar things happen when one clicks the Project url or the GitHub repository url. We know what was clicked and who did it. In the scores controller (the controllers/scores.js file) a query to fetch the users from a certain forum is made. Then we get the active scores and urls for the current phase of the contest and create an array which is passed to the scores view. To keep the users semi-anonymous, we change the usernames into Hacker {1-...} . Then the users array is shuffled. This is the code snippet which fetches the users, modifies the usernames and shuffles the array. User.model.find({ \"profile.hack_type\": user.profile.hack_type, \"profile.hack_id\": user.profile.hack_iand usls for the current phase of the contest and create an array which is passed to the scores view. }, (err, users) => { if (err) { return cb(err); } Settings.get((err, options) => { if (err) { return cb(err); } const phase = options.settings.hack_types[user.profile.hack_type].phase; users = users.map((u, i) => { u = u.toObject(); u.username = `Hacker ${i + 1}`; const phaseObj = Object(u.profile[phase]); return { _id: u._id, username: u.username, score_technical: phaseObj.score_technical, score_info_viz: phaseObj.score_info_viz, score_novelty: phaseObj.score_novelty, score_total: phaseObj.score_total, project_url: phaseObj.project_url, github_repo_url: phaseObj.github_repo_url }; }); shuffle(users); cb(null, { users: users, phase: phase }); }); }); The shuffle function is a basic algorithm of shuffling the elements from a given array: function shuffle(array) { var currentIndex = array.length, temporaryValue, randomIndex; // While there remain elements to shuffle... while (0 !== currentIndex) { // Pick a remaining element... randomIndex = Math.floor(Math.random() * currentIndex); currentIndex -= 1; // And swap it with the current element. temporaryValue = array[currentIndex]; array[currentIndex] = array[randomIndex]; array[randomIndex] = temporaryValue; } return array; } ================ Admin Interface ================ An admin can access additional functionality (such as deleting and editing any post). They have access to the dashboard ( /admin ) where they can make other users admins. If nobody is admin (say there are no users), we can make somebody an admin (even if they don\u2019t exist yet in the database) by assiging the GitHub username of an eventual user to the environment variable called ADMIN_USERNAME . The ADMIN_USERNAME environment variable represents the GitHub username of the user which should be an admin (this user cannot be a simple user anymore, nobody being able to remove the admin rights from them). When they are going to log in, they will be authenticated as admin. To set the ADMIN_USERNAME variable, there are multiple ways, but the easiest ones are: If the application runs in a Heroku environment, the variable can be set from the browser interface: https://dashboard.heroku.com/apps/<app-name>/settings , by clicking the Reveal Config Vars button or in the command line using: sh heroku config:set ADMIN_USERNAME=hackpurdue Note: after setting an enviroment variable on Heroku (either from the command line) or from the browser interface, the application will be restarted automatically. When running locally, the environment variable can be set when starting the app: sh ADMIN_USERNAME=hackpurdue npm run start:dev In the admin interface, the admin can: Change the Phase. Download the CSV stats. Set the start dates for each hack type. See all the users and update the scores for each and eventually make them admins. In case another user is made admin, they should log out (if they are authenticated) and log in back. ================================== Custom Database Filters for Admins ================================== For simple users, the database queries include the author , being the current authenticated user. When the user has admin permissions, we do not append anymore the author the queries, therefore making the queries more liberal, giving more power to the admin. For instance, when deleting a post, the user will create the following query: delete the post with _id =\u2026 and author=... Therefore, if the user tries to delete another post, having the id, that post will not be found because it is not created by the authenticated user. Tho, if the user is an admin, the query is simpler, lacking the author field (we want to give them the power to delete any post): *delete the post with _id=... * This is happening in the app/controllers/posts/_topicId-_slug/delete.js controller: const Topic = require(\"../../Topic\") , Session = require(\"../../Session\") ; exports.post = (lien, cb) => { const user = Session.getUser(lien); if (!user) { return lien.next(); } const filters = { _id: lien.params.topicId }; if (!Session.isAdmin(user)) { filters.author = user._id; } Topic.remove(filters, (err, count) => { if (err) { return lien.apiError(err); } lien.redirect(\"/\"); }) }; ===================== Application Structure ===================== In the routes folder, we have the page templates which are linked to the controllers from the controllers folder. routes/ \u251c\u2500\u2500 404.ajs \u251c\u2500\u2500 500.ajs \u251c\u2500\u2500 admin.ajs \u251c\u2500\u2500 countdown.ajs \u251c\u2500\u2500 index.ajs \u251c\u2500\u2500 logout.ajs \u251c\u2500\u2500 new.ajs \u251c\u2500\u2500 posts \u2502 \u251c\u2500\u2500 index.ajs \u2502 \u2514\u2500\u2500 _topicId-_slug \u2502 \u251c\u2500\u2500 comments.ajs \u2502 \u251c\u2500\u2500 delete.ajs \u2502 \u251c\u2500\u2500 edit.ajs \u2502 \u251c\u2500\u2500 index.ajs \u2502 \u2514\u2500\u2500 toggle-vote.ajs \u251c\u2500\u2500 quizzes.ajs \u251c\u2500\u2500 register.ajs \u251c\u2500\u2500 scores.ajs \u251c\u2500\u2500 search.ajs \u2514\u2500\u2500 users \u2514\u2500\u2500 _user \u251c\u2500\u2500 edit.ajs \u2514\u2500\u2500 index.ajs The _ character marks a dynamic route (such as a topic id/slug, or user). The controllers are: controllers/ \u251c\u2500\u2500 admin.js \u251c\u2500\u2500 Comment.js \u251c\u2500\u2500 countdown.js \u251c\u2500\u2500 HackTypes.js \u251c\u2500\u2500 index.js \u251c\u2500\u2500 login.js \u251c\u2500\u2500 logout.js \u251c\u2500\u2500 new.js \u251c\u2500\u2500 posts \u2502 \u2514\u2500\u2500 _topicId-_slug \u2502 \u251c\u2500\u2500 comments.js \u2502 \u251c\u2500\u2500 delete.js \u2502 \u251c\u2500\u2500 edit.js \u2502 \u251c\u2500\u2500 index.js \u2502 \u2514\u2500\u2500 toggle-vote.js \u251c\u2500\u2500 quizzes.js \u251c\u2500\u2500 register.js \u251c\u2500\u2500 scores.js \u251c\u2500\u2500 search.js \u251c\u2500\u2500 Session.js \u251c\u2500\u2500 Settings.js \u251c\u2500\u2500 Stats.js \u251c\u2500\u2500 Topic.js \u251c\u2500\u2500 User.js \u2514\u2500\u2500 users \u2514\u2500\u2500 _user \u251c\u2500\u2500 edit.js \u2514\u2500\u2500 index.js ======== Modules ======== In this application we use the following main modules: ===================== Database Connection ===================== To connect with the database the bloggify-mongoose module was used. The database models are stored in the app/models directory: models/ \u251c\u2500\u2500 Comment.js \u251c\u2500\u2500 Settings.js \u251c\u2500\u2500 Stats.js \u251c\u2500\u2500 Topic.js \u2514\u2500\u2500 User.js To see the raw database collections and documents, we can connect directly using the MongoDB CLI: mongo ....mlab.com:63758/heroku_... -u <dbuser> -p <dbpassword> or we can see that in the browser: Open the application Overview page https://dashboard.heroku.com/apps/ironhackplatform Clik the mLab MongoDB . This will redirect to an url like this: https://www.mlab.com/databases/heroku_... 3. On this page, we can see the collections and eventually the documents and edit them. The models we interact with are: Comment Stores the comments in the comments collection. module.exports = { author: \"string\", body: { type: String, text: true }, created_at: \"date\", topic: \"string\", votes: [\"string\"] }; Settings Stores the application settings. module.exports = { settings: \"object\" }; Stats Used to store the stats we collect. module.exports = { actor: \"string\", metadata: \"object\", event: \"string\", created_at: \"date\" }; In this collection we save the user events. See below what stats we collect. Topic Stores the topics in the topics collection. module.exports = { author: \"string\", title: { type: String, text: true }, slug: \"string\", body: { type: String, text: true }, created_at: \"date\", votes: [\"string\"], sticky: \"boolean\", metadata: \"object\" }; User Stores the users in the users collection. module.exports = { username: \"string\", email: \"string\", password: \"string\", profile: \"object\", role: \"string\" }; What stats we collect We collect stats when the user: clicks the View scores button opens a topic page The stats are collected by making HTTP requests to the server, using the fetch technology (it\u2019s a new browser API, similar to XHRHttpRequest ). The code snippets that take care of this is located in app/assets/javascripts/util/index.js : ... /** * post * Posts the data to the server. * * @name post * @function * @param {String} url The endpoint url. * @param {Object} data The post data. * @returns {Promise} The `fetch` promise. */ , post (url, data) { data._csrf = data._csrf || _pageData.csrfToken; return fetch(url, { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, credentials: \"same-origin\", body: JSON.stringify(data) }); } /** * getJSON * Fetches from the server JSON data. * * @name getJSON * @function * @param {String} url The endpoint url. * @returns {Promise} The `fetch` promise. */ , getJSON (url) { return fetch(url, { credentials: \"same-origin\" }).then(c => c.json()) } ... That\u2019s the low-level side of sending/receiving any data to/from the server using fetch . Note: some browsers don\u2019t have the fetch technology, therefore we use a polyfill created by GitHub to ensure the function is there. We collect three types of stats: view-topic Emitted when the user opens a topic. Metadata: topic_id : The topic id. topic_author : The user id of the topic author. Code snippet: js util.post(\"/api/stats\", { event: \"view-topic\", metadata: { topic_id: topic._id, topic_author: topic.author._id } }); score-click Emitted when the user clicks the View scores button. Metadata: hacker_id : The user that was clicked . Code snippet: js util.post(\"/api/stats\", { event: \"score-click\", metadata: { hacker_id: this.props.hacker._id } }); Clicks on the urls. The following events are emitted: click-project-url : When clicking the project url. click-github-repo-url : When clicking the GitHub repository url. Metadata: hacker_id : The hacker id from the table. url : The clicked url. Code snippet: js util.post(\"/api/stats\", { event: e.target.dataset.event, metadata: { hacker_id: this.props.hacker._id, url: e.target.href } }); The stats functionality on the server : On the server, we create a custom endpoint at /api/stats which expects POST data. We do not collect any stats from unauthenticated users. Along with the metadata we receive from the client side (see above) we add in the stat object the following information: actor : The current authenticated user id. event : The event name. user_agent : The user agent: this contains device and browser information. phase : The phase of the contest. The actor is the authenticated user id, and it will always be appended in the event object because we know there is an authenticated user. After we build the stats object, we call the Stats.record which will record the event in the database. The record method is not anything more than just a create query, after appending the created_at field in the event object. Bloggify.server.addPage(\"/api/stats\", \"post\", lien => { const user = Session.getUser(lien); if (!user) { return lien.next(); } const ev = { actor: user._id, event: lien.data.event, metadata: lien.data.metadata || {} }; ev.metadata.user_agent = lien.header(\"user-agent\"); Settings.get((err, settings) => { if (settings) { ev.metadata.phase = settings.settings.hack_types[user.profile.hack_type].phase; } Stats.record(ev, (err, data) => { if (err) { return lien.apiError(err); } lien.apiMsg(\"success\"); }); }); }); ===================== GitHub Login ===================== We used bloggify-github-login to handle the GitHub authentication. By providing the GitHub application credentials, this module handles the OAuth2 workflow. { \"githubClient\": \"45...7\", \"githubSecret\": \"1f...2\" } ===================== Email Notifications ===================== To send emails, we use bloggify-sendgrid . { \"key\": \"SG.SmlHGA...ylY\" } The notifications.js file takes care of sending the emails using this module. We send emails when: Somebody creates a new topic Emails are sent to all the users from the forum the author belongs to, except to the author. Somebody posts a comment Emails are sent to previous people involved in the conversation.","title":"Usage"},{"location":"App-Client/usage/#deploy","text":"When deployed to Heroku, the application url is https://<app-name>.herokuapp.com (unless it\u2019s using a custom domain). Note: When using a free dyno, it\u2019s working fine, but with some limitations: it\u2019s slower it\u2019s going to sleep if it\u2019s innactive for a certain period of time. it has bandwidth limits, but pretty liberal The app configuration is stored in the bloggify.js file. Make sure that the heroku remote exists (run git remote -v for that). If it doesn\u2019t exist, run: heroku git:remote ironhackplatform Commit all the changes and then run the following command: sh npm run deploy =============== Forum structure =============== You may specify the number of forums that you would like to have under the admin interface. ===================== Qualtrix Integration ===================== All the quizzes created on the Qualtrics platform have a snippet of JavaScript which stores the user data in the response (as known as Embedded data ). We store the user_email and the user_id which are sent in the url. The code in the Qualtrics quizzes is set in the last block, last question (which may happen to be an empty question, used for tracking): This approach is being used for all the quizzes: the sign up survey and the other technical quizzes. =============================== Login and Registration Process =============================== When the user is not authenticated, the main page displays two buttons: a login button and a Sign up button. When the login button is clicked, the /login url is opened. The login url redirects to the GitHub authentication workflow (OAuth2) where the user should accept access of our GitHub app in their GitHub account. The difference between the Sign in and Sign up buttons is that for the sign in, we assume that the user already has an account, therefore we make the redirection to GitHub APIs and authenticate them with their GitHub account. In case they do not have an account on the site, they will have to choose the hack type after the GitHub authentication. In Sign up case we will assume that the user doesn\u2019t have an account yet, therefore we ask them to choose the hack type and only then the GitHub authentication is made. Still, if an existing user clicks the Sign up button, they will log in into their account anyways. This is the authentication workflow: In the controllers/register.js file, we create a new user or authenticate an existing user. For the first-time users, we display the selection of the hack type: Purdue, Bogota and Platzi, and then redirect to the survey. At this moment, we start a session on the server side, but we don\u2019t write any data in the users\u2019 database yet. After the user completes the survey, they are redirected back, and the user account is created. To redirect the users to the survey, we send the Location header from the server to the client. Additional data is added in the url parameters to track the user: email : The email of the user user_id : The user id redirect_to : The redirection url where they will arrive after answering the survey. Using a JavaScript snippet in the survey page we store the email and the user id in the survey answer and we detect when the survey is done and redirect the users back to the app. When they finish the survey, they are redirected to the main app and the account is created. When creating a user account, we do not assign a hack_id to the user but we wait until the contest is started. The hack_id is a number based on which we create multiple forums inside of the same hack type. The range can be configured in the admin dashboard. If the user is already registered, they are authenticated based on the existing data. The hack_id values are assigned either when the user signs up (if the contest is already started) or when the contest starts. The default value for hack_id is null . This is changed automatically when the contest starts. The algorithm which assigns the hack ids is designed to create groups of an equal number of users. Specifically, the user will join in the hack id with the fewest users at that moment. The database query is: find how many users we have in each hack id, for a given hack type. Then, join the current user in the hack id with the fewest users. function generateGetHackId(hType, name) { return cb => { User.model.aggregate([{ $match: { \"profile.hack_id\": { $ne: null }, \"profile.hack_type\": name } }, { $group: { _id: \"$profile.hack_id\", total: { $sum: 1 } } }], (err, docs) => { if (err) { return cb(0); } const ids = Array(hType.subforums_count + 1).fill(0); docs.forEach(c => { ids[c._id] = c.total; }); let minId = 0; let min = ids[minId]; ids.forEach((count, index) => { if (count < min) { minId = index; min = ids[minId]; } }); cb(minId); }); }; } forEach(HACK_TYPES, (c, name) => { c.getHackId = generateGetHackId(c, name); }); The function which assigns the hack id values to the users is in the HackTypes controller ( app/controllers/HackTypes.js ). This function receives as input a hack type object and groups the users inside of the hack type. const assignHackIdsToUsers = hType => { const usersCursor = User.model.find({ \"profile.hack_id\": null, \"profile.hack_type\": hType.name }).cursor(); usersCursor.on(\"data\", cDoc => { usersCursor.pause(); hType.getHackId(uHackId => { User.update({ _id: cDoc._id }, { profile: { hack_id: uHackId } }, (err, data) => { if (err) { Bloggify.log(err); } usersCursor.resume(); }); }); }); usersCursor.on(\"error\", err => { Bloggify.log(err); }); usersCursor.on(\"end\", cDoc => { Bloggify.log(`Grouped the studends from ${hType.name}.`); }); }; The function above is called when the countdown finishes, being triggered by a scheduler: const setScheduleForHackType = name => { if (name.name) { name = name.name; } let hackTypeObj = HACK_TYPES[name]; if (hackTypeObj.startSchedule) { hackTypeObj.startSchedule.cancel(); } hackTypeObj.startSchedule = schedule.scheduleJob(hackTypeObj.start_date, () => { assignHackIdsToUsers(hackTypeObj); }); }; Or, it may be triggered when we make changes in the admin dashboard, changing the start of the contest. if (new Date() > thisHackType.start_date) { if (thisHackType.startSchedule) { thisHackType.startSchedule.cancel(); } assignHackIdsToUsers(thisHackType); } else { setScheduleForHackType(thisHackType); } To catch the save event, we add a hook using the addHook method defined by the bloggify-mongoose plugin. Settings.model.addHook(\"post\", \"save\", update); ======== Quizzes ======== The quizzes page displays the quizzes that can be taken by the user. The user may answer the same quiz multiple times. In the view file ( app/routes/quizzes.ajs ) we have the part which renders the links to each quiz: <% include(\"../views/header\", { title: \"Quizzes\" }) %> <% include(\"../views/container/start\") %> <h1>Quizzes</h1> <% quizzes.forEach(function (quiz) { %> <a class=\"btn\" href=\"<%= quiz.url %>\"><%= quiz.label %></a> <% }); %> <% include(\"../views/container/end\") %> <% include(\"../views/footer\") %> The data associated with this view is storred in the controller ( app/controllers/quizzes.js )\u2013see below. The user can click the generated link which contains information about the user (the email address and the user id)\u2013which are storred in the Qualtrics quiz responses as embedded data, and also the redirect url. When the user finishes the quiz, they are redirected back the application, on the /quizzes page and the application marks the quiz complete internally. Even the quiz was completed, the user can take it again. const Bloggify = require(\"bloggify\") , Session = require(\"./Session\") , User = require(\"./User\") , findValue = require(\"find-value\") ; // Define the quizzes list const quizzes = [ [\"d3.js\", \"https://purdue.qualtrics.com/jfe/form/SV_71xEzp5vQ7rC817\", \"d3\"] , [\"HTML & CSS\", \"https://purdue.qualtrics.com/jfe/form/SV_do6Sc9VJsAMmOih\", \"html_css\"] , [\"JavaScript & jQuery\", \"https://purdue.qualtrics.com/jfe/form/SV_b8zyxX8wozQfNul\", \"javascript_jquery\"] ]; // Map the quizzes labels to the data const validQuizzes = {}; quizzes.forEach(c => { validQuizzes[c[2]] = c; }); module.exports = (lien, cb) => { const user = Session.getUser(lien); if (!user) { return lien.redirect(\"/\"); } // Set the quiz complete const completed = lien.query.markComplete; if (completed && validQuizzes[completed]) { return User.update({ _id: user._id }, { profile: { surveys: { [completed]: { ended_at: new Date() } } } }, (err, _user) => { lien.redirect(\"/quizzes\"); }) } // Generate the redirect links const completedSurveys = findValue(user, \"profile.surveys\") || {}; const userQuizzes = quizzes.map(c => { const redirectTo = encodeURIComponent(`${Bloggify.options.metadata.domain}/quizzes?markComplete=${c[2]}`); return { label: c[0] , url: `${c[1]}?redirect_to=${redirectTo}&user_email=${user.email}&user_id=${user._id}` , is_complete: !!completedSurveys[c[2]] }; }); // Send the quizzes array to the view cb(null, { quizzes: userQuizzes }); }; ======== Search ======== On the search page ( /search ) we can search for content which appears either in the post data or in the comments. The view associated with this page is storred in the app/routes/search.ajs and it looks like this: <% include(\"../views/header\", { title: \"Search\" }) %> <% include(\"../views/container/start\") %> <h1>Search</h1> <div class=\"search-form-wrapper\"> <% include(\"../views/search-form\") %> </div> <% if (f(\"results\")) { %> <p class=\"search-results-text\">Search results for <em>\u2018<%= lien.query.search %>\u2019</em></p> <div class=\"search-results\"> <% if (results.length) { %> <% results.forEach(function (cResult) { %> <div class=\"seach-result-item\"> <h2> <a href=\"<%= cResult.url %>\"> <%= cResult.title %> </a> </h2> </div> <% }) %> <% } else { %> <div class=\"no-search-results\"> There are no results. Maybe try a different query. </div> <% } %> </div> <% } %> <% include(\"../views/container/end\") %> <% include(\"../views/footer\") %> This file requires the search-form which appears in the app/views/search-form.ajs file, representing the search form itself: <form> <input type=\"text\" name=\"search\" value=\"<%= lien.query.search || \"\" %>\" placeholder=\"Search for something...\" /> </form> When the user submits the query, the ?search=<query> querystring parameter is added in the url, triggering the search functionality in the controller (located in app/controllers/search.js ). To increase the search results accuracy we used the internal MongoDB text search indexes like this: we created text indexes for the topic title and content and comment content, using the text: true in the model configuration: app/models/Topic.js : module.exports = { ... title: { type: String, text: true }, ... body: { type: String, text: true }, ... }; app/models/Comment.js : module.exports = { ... body: { type: String, text: true }, ... }; Note : The admin users will see the search results from all the forums, while the simple users will see the search results from the forum they belong to. The controller which takes care of searching looks like this: const Session = require(\"./Session\") , Topic = require(\"./Topic\") , Comment = require(\"./Comment\") ; module.exports = (lien, cb) => { const user = Session.getUser(lien); if (!user) { return lien.redirect(\"/\"); } const isAdmin = Session.isAdmin(user); // Perform the search query if (lien.query.search) { // Use the $text index to search const filters = { $text: { $search: lien.query.search } }; let results = {}; // Search in the topics and comments Promise.all([ Topic.model.find(filters) , Comment.model.find(filters) ]).then(data => { results.topics = data[0]; results.comments = data[1].map(c => c.toObject()); return Promise.all(results.comments.map(cComment => { return Topic.model.findOne({ _id: cComment.topic }); })); }).then(topics => { let uniqueTopics = {}; results.topics.concat(topics).forEach(c => { if (!c) { return; } // Let the admin see all the posts/comments in all the forums if (!isAdmin) { if (c.metadata.hack_type !== user.profile.hack_type || c.metadata.hack_id !== user.profile.hack_id) { return; } } uniqueTopics[c._id] = c; c.url = Topic.getUrl(c); }); cb(null, { results: Object.keys(uniqueTopics).map(k => uniqueTopics[k]) }); }).catch(e => { cb(e); }); } else { cb(); } }; ========== Posts Page ========== For authenticated users, we display the posts on the first page, ordered by the date, but the sticky posts are always the first ones. Only the admin users can make create sticky posts (or edit a post and make it sticky). Here, the users from a specific forum can see and upvote the posts from the same forum. They can click on the post urls and post comments. ===================== Single Posts Page ===================== The single post pages are accessible by authenticated users only. They display the post title, body, votes and comments. In case somebody comments, the comments are updated in real-time, the votes too. When a user opens a topic page, we collect stats about that event: actor : the user id who clicked the button topic_id : the topic id phase : the phase of the project created_at : the timestamp ===================== Posting a New Topic ===================== By accessing the /new endpoint, one can post a topic in their forum. They have to write the title and the topic content. The topic content can be styled with Markdown specific styles (bold, italic etc). ======================== Display Page Manipulated ======================== We display the scores of the users, on the /scores page. The users see the anonymous name of the users in the table. The displayed items in the table are shuffled each time. If in the admin interface the scores are not provided, the scores collumns will not appear in the scores. In a similar way it happens for the urls: if we don\u2019t enter the urls, the urls collumns will not appear in the scores page. When the user clicks on the View scores button, we collect stats: actor : the user id who clicked the button hacker_id : the user from the table which was clicked phase : the phase of the project created_at : the timestamp Similar things happen when one clicks the Project url or the GitHub repository url. We know what was clicked and who did it. In the scores controller (the controllers/scores.js file) a query to fetch the users from a certain forum is made. Then we get the active scores and urls for the current phase of the contest and create an array which is passed to the scores view. To keep the users semi-anonymous, we change the usernames into Hacker {1-...} . Then the users array is shuffled. This is the code snippet which fetches the users, modifies the usernames and shuffles the array. User.model.find({ \"profile.hack_type\": user.profile.hack_type, \"profile.hack_id\": user.profile.hack_iand usls for the current phase of the contest and create an array which is passed to the scores view. }, (err, users) => { if (err) { return cb(err); } Settings.get((err, options) => { if (err) { return cb(err); } const phase = options.settings.hack_types[user.profile.hack_type].phase; users = users.map((u, i) => { u = u.toObject(); u.username = `Hacker ${i + 1}`; const phaseObj = Object(u.profile[phase]); return { _id: u._id, username: u.username, score_technical: phaseObj.score_technical, score_info_viz: phaseObj.score_info_viz, score_novelty: phaseObj.score_novelty, score_total: phaseObj.score_total, project_url: phaseObj.project_url, github_repo_url: phaseObj.github_repo_url }; }); shuffle(users); cb(null, { users: users, phase: phase }); }); }); The shuffle function is a basic algorithm of shuffling the elements from a given array: function shuffle(array) { var currentIndex = array.length, temporaryValue, randomIndex; // While there remain elements to shuffle... while (0 !== currentIndex) { // Pick a remaining element... randomIndex = Math.floor(Math.random() * currentIndex); currentIndex -= 1; // And swap it with the current element. temporaryValue = array[currentIndex]; array[currentIndex] = array[randomIndex]; array[randomIndex] = temporaryValue; } return array; } ================ Admin Interface ================ An admin can access additional functionality (such as deleting and editing any post). They have access to the dashboard ( /admin ) where they can make other users admins. If nobody is admin (say there are no users), we can make somebody an admin (even if they don\u2019t exist yet in the database) by assiging the GitHub username of an eventual user to the environment variable called ADMIN_USERNAME . The ADMIN_USERNAME environment variable represents the GitHub username of the user which should be an admin (this user cannot be a simple user anymore, nobody being able to remove the admin rights from them). When they are going to log in, they will be authenticated as admin. To set the ADMIN_USERNAME variable, there are multiple ways, but the easiest ones are: If the application runs in a Heroku environment, the variable can be set from the browser interface: https://dashboard.heroku.com/apps/<app-name>/settings , by clicking the Reveal Config Vars button or in the command line using: sh heroku config:set ADMIN_USERNAME=hackpurdue Note: after setting an enviroment variable on Heroku (either from the command line) or from the browser interface, the application will be restarted automatically. When running locally, the environment variable can be set when starting the app: sh ADMIN_USERNAME=hackpurdue npm run start:dev In the admin interface, the admin can: Change the Phase. Download the CSV stats. Set the start dates for each hack type. See all the users and update the scores for each and eventually make them admins. In case another user is made admin, they should log out (if they are authenticated) and log in back. ================================== Custom Database Filters for Admins ================================== For simple users, the database queries include the author , being the current authenticated user. When the user has admin permissions, we do not append anymore the author the queries, therefore making the queries more liberal, giving more power to the admin. For instance, when deleting a post, the user will create the following query: delete the post with _id =\u2026 and author=... Therefore, if the user tries to delete another post, having the id, that post will not be found because it is not created by the authenticated user. Tho, if the user is an admin, the query is simpler, lacking the author field (we want to give them the power to delete any post): *delete the post with _id=... * This is happening in the app/controllers/posts/_topicId-_slug/delete.js controller: const Topic = require(\"../../Topic\") , Session = require(\"../../Session\") ; exports.post = (lien, cb) => { const user = Session.getUser(lien); if (!user) { return lien.next(); } const filters = { _id: lien.params.topicId }; if (!Session.isAdmin(user)) { filters.author = user._id; } Topic.remove(filters, (err, count) => { if (err) { return lien.apiError(err); } lien.redirect(\"/\"); }) }; ===================== Application Structure ===================== In the routes folder, we have the page templates which are linked to the controllers from the controllers folder. routes/ \u251c\u2500\u2500 404.ajs \u251c\u2500\u2500 500.ajs \u251c\u2500\u2500 admin.ajs \u251c\u2500\u2500 countdown.ajs \u251c\u2500\u2500 index.ajs \u251c\u2500\u2500 logout.ajs \u251c\u2500\u2500 new.ajs \u251c\u2500\u2500 posts \u2502 \u251c\u2500\u2500 index.ajs \u2502 \u2514\u2500\u2500 _topicId-_slug \u2502 \u251c\u2500\u2500 comments.ajs \u2502 \u251c\u2500\u2500 delete.ajs \u2502 \u251c\u2500\u2500 edit.ajs \u2502 \u251c\u2500\u2500 index.ajs \u2502 \u2514\u2500\u2500 toggle-vote.ajs \u251c\u2500\u2500 quizzes.ajs \u251c\u2500\u2500 register.ajs \u251c\u2500\u2500 scores.ajs \u251c\u2500\u2500 search.ajs \u2514\u2500\u2500 users \u2514\u2500\u2500 _user \u251c\u2500\u2500 edit.ajs \u2514\u2500\u2500 index.ajs The _ character marks a dynamic route (such as a topic id/slug, or user). The controllers are: controllers/ \u251c\u2500\u2500 admin.js \u251c\u2500\u2500 Comment.js \u251c\u2500\u2500 countdown.js \u251c\u2500\u2500 HackTypes.js \u251c\u2500\u2500 index.js \u251c\u2500\u2500 login.js \u251c\u2500\u2500 logout.js \u251c\u2500\u2500 new.js \u251c\u2500\u2500 posts \u2502 \u2514\u2500\u2500 _topicId-_slug \u2502 \u251c\u2500\u2500 comments.js \u2502 \u251c\u2500\u2500 delete.js \u2502 \u251c\u2500\u2500 edit.js \u2502 \u251c\u2500\u2500 index.js \u2502 \u2514\u2500\u2500 toggle-vote.js \u251c\u2500\u2500 quizzes.js \u251c\u2500\u2500 register.js \u251c\u2500\u2500 scores.js \u251c\u2500\u2500 search.js \u251c\u2500\u2500 Session.js \u251c\u2500\u2500 Settings.js \u251c\u2500\u2500 Stats.js \u251c\u2500\u2500 Topic.js \u251c\u2500\u2500 User.js \u2514\u2500\u2500 users \u2514\u2500\u2500 _user \u251c\u2500\u2500 edit.js \u2514\u2500\u2500 index.js ======== Modules ======== In this application we use the following main modules: ===================== Database Connection ===================== To connect with the database the bloggify-mongoose module was used. The database models are stored in the app/models directory: models/ \u251c\u2500\u2500 Comment.js \u251c\u2500\u2500 Settings.js \u251c\u2500\u2500 Stats.js \u251c\u2500\u2500 Topic.js \u2514\u2500\u2500 User.js To see the raw database collections and documents, we can connect directly using the MongoDB CLI: mongo ....mlab.com:63758/heroku_... -u <dbuser> -p <dbpassword> or we can see that in the browser: Open the application Overview page https://dashboard.heroku.com/apps/ironhackplatform Clik the mLab MongoDB . This will redirect to an url like this: https://www.mlab.com/databases/heroku_... 3. On this page, we can see the collections and eventually the documents and edit them. The models we interact with are:","title":"Deploy"},{"location":"App-Client/usage/#comment","text":"Stores the comments in the comments collection. module.exports = { author: \"string\", body: { type: String, text: true }, created_at: \"date\", topic: \"string\", votes: [\"string\"] };","title":"Comment"},{"location":"App-Client/usage/#settings","text":"Stores the application settings. module.exports = { settings: \"object\" };","title":"Settings"},{"location":"App-Client/usage/#stats","text":"Used to store the stats we collect. module.exports = { actor: \"string\", metadata: \"object\", event: \"string\", created_at: \"date\" }; In this collection we save the user events. See below what stats we collect.","title":"Stats"},{"location":"App-Client/usage/#topic","text":"Stores the topics in the topics collection. module.exports = { author: \"string\", title: { type: String, text: true }, slug: \"string\", body: { type: String, text: true }, created_at: \"date\", votes: [\"string\"], sticky: \"boolean\", metadata: \"object\" };","title":"Topic"},{"location":"App-Client/usage/#user","text":"Stores the users in the users collection. module.exports = { username: \"string\", email: \"string\", password: \"string\", profile: \"object\", role: \"string\" };","title":"User"},{"location":"App-Client/usage/#what-stats-we-collect","text":"We collect stats when the user: clicks the View scores button opens a topic page The stats are collected by making HTTP requests to the server, using the fetch technology (it\u2019s a new browser API, similar to XHRHttpRequest ). The code snippets that take care of this is located in app/assets/javascripts/util/index.js : ... /** * post * Posts the data to the server. * * @name post * @function * @param {String} url The endpoint url. * @param {Object} data The post data. * @returns {Promise} The `fetch` promise. */ , post (url, data) { data._csrf = data._csrf || _pageData.csrfToken; return fetch(url, { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, credentials: \"same-origin\", body: JSON.stringify(data) }); } /** * getJSON * Fetches from the server JSON data. * * @name getJSON * @function * @param {String} url The endpoint url. * @returns {Promise} The `fetch` promise. */ , getJSON (url) { return fetch(url, { credentials: \"same-origin\" }).then(c => c.json()) } ... That\u2019s the low-level side of sending/receiving any data to/from the server using fetch . Note: some browsers don\u2019t have the fetch technology, therefore we use a polyfill created by GitHub to ensure the function is there. We collect three types of stats: view-topic Emitted when the user opens a topic. Metadata: topic_id : The topic id. topic_author : The user id of the topic author. Code snippet: js util.post(\"/api/stats\", { event: \"view-topic\", metadata: { topic_id: topic._id, topic_author: topic.author._id } }); score-click Emitted when the user clicks the View scores button. Metadata: hacker_id : The user that was clicked . Code snippet: js util.post(\"/api/stats\", { event: \"score-click\", metadata: { hacker_id: this.props.hacker._id } }); Clicks on the urls. The following events are emitted: click-project-url : When clicking the project url. click-github-repo-url : When clicking the GitHub repository url. Metadata: hacker_id : The hacker id from the table. url : The clicked url. Code snippet: js util.post(\"/api/stats\", { event: e.target.dataset.event, metadata: { hacker_id: this.props.hacker._id, url: e.target.href } }); The stats functionality on the server : On the server, we create a custom endpoint at /api/stats which expects POST data. We do not collect any stats from unauthenticated users. Along with the metadata we receive from the client side (see above) we add in the stat object the following information: actor : The current authenticated user id. event : The event name. user_agent : The user agent: this contains device and browser information. phase : The phase of the contest. The actor is the authenticated user id, and it will always be appended in the event object because we know there is an authenticated user. After we build the stats object, we call the Stats.record which will record the event in the database. The record method is not anything more than just a create query, after appending the created_at field in the event object. Bloggify.server.addPage(\"/api/stats\", \"post\", lien => { const user = Session.getUser(lien); if (!user) { return lien.next(); } const ev = { actor: user._id, event: lien.data.event, metadata: lien.data.metadata || {} }; ev.metadata.user_agent = lien.header(\"user-agent\"); Settings.get((err, settings) => { if (settings) { ev.metadata.phase = settings.settings.hack_types[user.profile.hack_type].phase; } Stats.record(ev, (err, data) => { if (err) { return lien.apiError(err); } lien.apiMsg(\"success\"); }); }); }); ===================== GitHub Login ===================== We used bloggify-github-login to handle the GitHub authentication. By providing the GitHub application credentials, this module handles the OAuth2 workflow. { \"githubClient\": \"45...7\", \"githubSecret\": \"1f...2\" } ===================== Email Notifications ===================== To send emails, we use bloggify-sendgrid . { \"key\": \"SG.SmlHGA...ylY\" } The notifications.js file takes care of sending the emails using this module. We send emails when: Somebody creates a new topic Emails are sent to all the users from the forum the author belongs to, except to the author. Somebody posts a comment Emails are sent to previous people involved in the conversation.","title":"What stats we collect"},{"location":"Cloud-Api/overview/","text":"Introduction This repository contain the Firebase Cloud Function project that take care of the server duties on the IronHacks platform (the platform). Keep in mind that the platform doesn\u2019t have a proper backend, the following cloud functions are all the platform needs in order to communicate with the firebase database (both the db and the storage). For documentation about the client, go to The IronHacks Platform repository. The need for a backend on the platform obey to three mayor components: the admin side, the previsualization of a project on the editor and the GitHub integration. All of these requirements are solve using one or more cloud function, saving us the cost of server maintenance. Repository References Development Dev Scripts and Build Utilities serve start shell Deploying Once the configuration is done, the next step is to deploy your functions using the Firebase CLI: firebase deploy --only functions This command will deploy all the functions on the project, and know we can actually talk about the functions:","title":"Overview"},{"location":"Cloud-Api/overview/#introduction","text":"This repository contain the Firebase Cloud Function project that take care of the server duties on the IronHacks platform (the platform). Keep in mind that the platform doesn\u2019t have a proper backend, the following cloud functions are all the platform needs in order to communicate with the firebase database (both the db and the storage). For documentation about the client, go to The IronHacks Platform repository. The need for a backend on the platform obey to three mayor components: the admin side, the previsualization of a project on the editor and the GitHub integration. All of these requirements are solve using one or more cloud function, saving us the cost of server maintenance.","title":"Introduction"},{"location":"Cloud-Api/overview/#repository","text":"","title":"Repository"},{"location":"Cloud-Api/overview/#references","text":"","title":"References"},{"location":"Cloud-Api/overview/#development","text":"Dev Scripts and Build Utilities serve start shell","title":"Development"},{"location":"Cloud-Api/overview/#deploying","text":"Once the configuration is done, the next step is to deploy your functions using the Firebase CLI: firebase deploy --only functions This command will deploy all the functions on the project, and know we can actually talk about the functions:","title":"Deploying"},{"location":"Cloud-Api/requirements/","text":"Dependencies The Ironhacks Platform (the platform) use the following firebase services: Authentication Cloud Firestore Storage Hosting Cloud Functions Firebase Auth UI We assume you are familiarized with all these services, how they work, and how to code using them. If you are not familiarized with them please check the Firebase documentation. In addition, we use the following libraries/third party utilities: Octonode (A nodeJS library to access Github V3 API) AWS-SKD Amazon SES We assume you are familiarized with all these librarires, how they work, and how to code using them. If you are not familiarized with them please check the documentation of each one. This Firebase project performs third party calls, therefore it must be enrolled in a paid plan (we suggest the Blaze plan), however, this is not completely necessary, since you can opt to not have neither email notifications (via Amazon SES) nor GitHub support. If you choose to use them, you will have to setup the amazon SES service, and since the platform creates private repositories into GitHub, you will also have to have a PRO account.","title":"Requirements"},{"location":"Cloud-Api/setup/","text":"Setting up the dev environment This is a clasic Firebase Cloud Functions project, so the \u201cinstalation process\u201d is just deploy the functions (AKA this project) into your firebase project. In that matter, we recommend you to use this project as template for your implementation of the platform. In order to set it up do the following: Setting up the Firebase Cloud Functions project Create a Firebase Project from The Firebase Console (If you start by the Platform Repository you propably arlready did this) Initialize the Cloud Functions in your project ( Getting Started Cloud Funtions ) Clone this repo into a diferent folder in your local machine: bash git clone https://github.com/RCODI/the-ironhacks-platform-backend.git Now, go to your project folder and copy the service-account.json file located in the functions folder. Paste into the the-ironhacks-platform-backend repo you just clone, in the same functions folder. This will link the functions on this project with your own Firebase project. Now we need to add the Amazon SES and the Github V3 API keys in order to enable the notifications (via email) for the forum and the automatic repository creation on github. Setting the enviroment variables If you are not familiar with the base Environment configuration, check the docs In order to make work, you must set the following env variables: From your firebase project: database.url = \u201cRealtime database URL\u201d (Keep in mind we don\u2019t use it, this is just to create the admin instance.) Docs database.bucket = \u201cYour storage bucket URL\u201d Docs From Amazon SES: amazonses.key: \u201cYour Key\u201d amazonses.secret: \u201cYour Secret\u201d From Github githubapi.personalkey: \u201cYour Key\u201d NOTE: You need to create the service-account.json file on the Firebase console see url: ___ Do not commit this file to the project repo Initialization Keep in mind that once you set this variables, they are storage in the firebase project itself, not in your local machine, therefore there is not need to set them again if you switch to another computer. IMPORTANT: The pirvate keys ARE PRIVATE, do not upload to github nor share those key in the web. this is sencible data that should remain in a save local machine, under the responsibility of the administrator of the project. If you are not sure about how to get these keys, please refer to the documentation of each library.","title":"Setup"},{"location":"Cloud-Api/setup/#setting-up-the-dev-environment","text":"This is a clasic Firebase Cloud Functions project, so the \u201cinstalation process\u201d is just deploy the functions (AKA this project) into your firebase project. In that matter, we recommend you to use this project as template for your implementation of the platform. In order to set it up do the following:","title":"Setting up the dev environment"},{"location":"Cloud-Api/setup/#setting-up-the-firebase-cloud-functions-project","text":"Create a Firebase Project from The Firebase Console (If you start by the Platform Repository you propably arlready did this) Initialize the Cloud Functions in your project ( Getting Started Cloud Funtions ) Clone this repo into a diferent folder in your local machine: bash git clone https://github.com/RCODI/the-ironhacks-platform-backend.git Now, go to your project folder and copy the service-account.json file located in the functions folder. Paste into the the-ironhacks-platform-backend repo you just clone, in the same functions folder. This will link the functions on this project with your own Firebase project. Now we need to add the Amazon SES and the Github V3 API keys in order to enable the notifications (via email) for the forum and the automatic repository creation on github.","title":"Setting up the Firebase Cloud Functions project"},{"location":"Cloud-Api/setup/#setting-the-enviroment-variables","text":"If you are not familiar with the base Environment configuration, check the docs In order to make work, you must set the following env variables: From your firebase project: database.url = \u201cRealtime database URL\u201d (Keep in mind we don\u2019t use it, this is just to create the admin instance.) Docs database.bucket = \u201cYour storage bucket URL\u201d Docs From Amazon SES: amazonses.key: \u201cYour Key\u201d amazonses.secret: \u201cYour Secret\u201d From Github githubapi.personalkey: \u201cYour Key\u201d NOTE: You need to create the service-account.json file on the Firebase console see url: ___ Do not commit this file to the project repo","title":"Setting the enviroment variables"},{"location":"Cloud-Api/setup/#initialization","text":"Keep in mind that once you set this variables, they are storage in the firebase project itself, not in your local machine, therefore there is not need to set them again if you switch to another computer. IMPORTANT: The pirvate keys ARE PRIVATE, do not upload to github nor share those key in the web. this is sencible data that should remain in a save local machine, under the responsibility of the administrator of the project. If you are not sure about how to get these keys, please refer to the documentation of each library.","title":"Initialization"},{"location":"Cloud-Api/usage/","text":"GitHub API commitToGitHub createGitHubRepo The flow here is quite simple, we a user creates a project, create that project in two different places: The user\u2019s firebase storage folder and the GitHub organization specified on the initialization section. The user will query the Firebase storage when using the platform, so we always store the latest version of the user project there. However, for the judger to work, we ask the user to \u201cpush\u201d the version that is going to be evaluated. This \u201cpush\u201d actually pushes the files to the GitHub repo. So the judger can retrieve them from GitHub. Keep in mind that this is transparent for the user. Github Configuration const github = require(\"octonode\"); const githubPersonalAccessToken = process.env.GITHUB_ACCESS_TOKEN; const client = github.client(githubPersonalAccessToken); const ghme = client.me(); const ghorg = client.org(\"UNALIronHacks\"); module.exports = { github: github, client: client, me: ghme, org: ghorg, }; Let\u2019s start by the GitHub repository creation: createGithubRepo Parameters: const newRepoConfig = { name: projectName, description: 'UNAL-ironhacks-spring-2019', private: true, auto_init: true, } exports.createGitHubRepo = functions.https.onCall(async (data, context) => { try { const result = await ghorg.repoAsync(data); return result; } catch(err) { return {message: 'Error', error: err, status: 500}; } }) This function is really simple, is just a call to the Octonode library (check their docs ) to create a new empty repo. Please refer to the Octonode docs to understand how ghrepo.contentsAsync , ghrepo.updateContentsAsync and ghrepo.createContentsAsync works. commitToGitHub Main function that submits the committed files to the GitHub API const commitToGitHub = functions.https.onCall(async (data, context) => { const ghrepo = gh.client.repo(\"UNALIronHacks/\" + data.name); const { commitMessage, files } = data; const result = await commitChanges(commitMessage, files, ghrepo); return result; }); Project Editor previewWebServer Account Management registerUser Utilities getPhaseResults getTaskDoc saveLikedCompetitors saveStat Amazon SES & Forum newThreadEmailNotification admin.initializeApp({ credential: admin.credential.cert(serviceAccount), databaseURL: functions.config().database.url }); Besides import the libraries required (we will address them on the fuctions in where they are used, if needed), there are some importants things you should check: const newThreadEmailNotification = require('./amazonSESfunctions'); The email functionality is in it own js file, and we import them here just to export it amogn the bundle. (We will address it at the end) const serviceAccount = require('./service-account.json'); Here we import our Firebase project keys from a local file, remember, you should not upload this file to the repository. And just after that, we initialized the Firebase admin library: admin.initializeApp({ credential: admin.credential.cert(serviceAccount), databaseURL: functions.config().database.url }); Notice how we access to the env variables in order to get the database URL. Here we catch the personal key from the env variables, then we use it to create the instance of github octonode. const githubPersonalAccessToken = functions.config().githubapi.personalkey; And then we create the \u201cuser\u201d object and also select the organization on which we will create the repositories of the projects. Remember that this have to be a PRO user and a PRO organization in order to be able to create private repos. (Please check the Octonode docs if you feel rusty here); in this case the organization is called \u201cUNALIronhacks\u201d, this was the one we used back then, you should put your own one there. const ghme = client.me(); const ghorg = client.org('UNALIronHacks'); Registration Process The first group of functions is related with the registration process of an user and is composed by two functions: exports.registerUser = functions.https.onCall((data, context) => {...}) const getNewParticipantForumId = (hackId, userId) => {...} As you can see, only one function is exported, registerUser . getPartipantForumId is and utility used by the first one. registerUser(hackID) On ./functions/index.js Parameters: { \"hackId\": \"hackId\"} hackId is the id from a hack documment on the database. exports.registerUser = functions.https.onCall((data, context) => { return db.collection(\"adminHackData\") .doc(data.hackId) .set({ registeredUsers: admin.firestore.FieldValue.arrayUnion(context.auth.uid) }, {merge: true}) .then((result) => { return getNewParticipantForumId(data.hackId, context.auth.uid) .then((forum) => { return db.collection('users') .doc(context.auth.uid) .set({ hacks: admin.firestore.FieldValue.arrayUnion(data.hackId), forums: forum, }, {merge: true}) .then((result) => { return {message: 'success', status: 200}; }) .catch(error => { return {message: error, status: 500}; }) }) .catch(error => { return {message: error, status: 500}; }) }) .catch(error => { return {message: error, status: 500}; }) }); This function will retrieve the hack data corresponding with the hackId sended as parameter from the adminHackData colletion, it will add the userID to the registeredUsers array and update the hack document. Then, it will ask for the forumID the user was register on and will update the user\u2019s documment, adding the hackID and the forumID to it. getNewParticipantForumId(hackId, userId) On ./functions/index.js Parameters: hackID : String userID : String const getNewParticipantForumId = (hackId, userId) => { return db.collection(\"forums\") .where('hack', '==', hackId) .get() .then((querySnapshot) => { let selectedForum; let forumParticipants = -1; querySnapshot.forEach((doc) => { const legth = Object.keys(doc.data().participants) if(forumParticipants === -1){ selectedForum = doc; forumParticipants = Object.keys(doc.data().participants); }else if(Object.keys(doc.data().participants).length < forumParticipants.length){ selectedForum = doc; forumParticipants = Object.keys(doc.data().participants); } }); return db.collection('forums').doc(selectedForum.id) .set({participants: {[userId]: `Hacker ${forumParticipants.length + 1}`}}, {merge: true}) .then(() => { const forum = {}; forum[hackId] = {id: selectedForum.id}; return forum; }) .catch(error => { return {message: error, status: 500}; }) }).catch(error => { return {message: error, status: 500}; }) } This function will search into the formus of a given hack (hackID) the one which have the less participants registered on, then it will register the new participant (userID) on it and will return the forum id. Project Editor Now we are going to describe the function related with the project editor: exports.previewWebServer = functions.https.onRequest((req, res) => {...}) Although you could say that the Github API are also related, for the sake of consistency, we are going to separate the thirdh party ones from this group. One of the biggest needs to the platform is to be able to preview the mockup that is being developed by a participant. Basically, to have a web server. However, What the platform tryes to do here is to mimik the behaviour of a web server, using only cloud functions. Even if a first glance it looks like an over engineered solution, the idea here is to have the less amount of compoenents posible and create a platform easy to use. Preview (AKA Web Server) The preview system relies on to key components, the previewWebServer function and the rewrite is defined on the config file: On ./firebase.json ... \"rewrites\": [ { \"source\": \"/preview/**\", \"function\": \"previewWebServer\" }, { \"source\": \"**\", \"destination\": \"/index.html\" } ] }, ... First, let\u2019s look the config file: We are redirecting everything that go to the preview url to call the previewWebServer function, this allow the function to be triggered whenever a file for a given is requested. Let\u2019s check the function itself: exports.previewWebServer = functions.https.onRequest((req, res) => { const filePathStorage = req.originalUrl.replace('/preview', ''); const fileName = path.basename(filePathStorage); const tempPath = path.join(os.tmpdir(), `${fileName}`); return storage .bucket(functions.config().database.bucket) .file(filePathStorage) .download({ destination: tempPath, }).then(() => { res.sendFile(tempPath, (err) => { if (err) { return res.end(); }else{ return res.end(); } }); }).catch((error) => { console.error(error.message); if(error.message === 'Not Found') { console.error('File not found', filePathStorage); return res.status(404).send('File not found on storage'); }else{ return res.status(500).send(error.message); } }) }); We call this function directly from the browser (since the idea is to replicate a web server), and the structure of the URL is the following: const projectURL = `${Constants.cloudFunctionsProdEndPoint}/previewWebServer/${this.state.user.uid}/${this.state.projectName}/index.html`; The Constants.cloudFunctionsProdEnd is the endpoint of your firebase cloud functions project. This function will retrieve the resource requested on the path, in this case, we allways start by de index.html. Once the index.html is loaded by the browser, it will call again the same function in order to load additional assets, for example, a javascript file. Since we rewrite de function, everytime the browser request other file, like js/main.js it will be redirected to the previewWebServer function, and it will retrieve the file. Keep in mind that this function retrieve the files from the Firebase storage service. Experiment related functions Since the main idea of the platform is to create specific conditions related with the experiment that is being done, the platform exposes 4 particular functions that will help you to do that: exports.getTaskDoc = functions.https.onCall((data, context) => {...} exports.saveStat = functions.https.onCall((data, context) => {...} exports.getPhaseResults = functions.https.onCall((data, context) => {...} exports.saveLikedCompetitors = functions.https.onCall((data, context) => {...} Let\u2019s start by the most basic: getTaskDoc This function return the Task document, this is the documment that contains the challenge or problem the participants of a hack will face. Keep in mind that the document will only be served if the publish date already pass. Also keep in mind that the content of the file is encode in base64. exports.getTaskDoc = functions.https.onCall((data, context) => { const currentDate = new Date(); return db.collection(\"adminHackData\") .doc(data.hackId) .get() .then((doc) => { const seconds = doc.data().task.releaseDate._seconds const nanoseconds = doc.data().task.releaseDate._nanoseconds const releaseDate = new admin.firestore.Timestamp(seconds, nanoseconds).toDate(); if(releaseDate < currentDate){ return {task: doc.data().task.doc}; }else { return {error: 'To early', status: 500}; } }) .catch(error => { console.error(error); return {message: error, status: 500}; }) }); saveStat The platform allows you to collect stats, you can pretty much collect every single interaction and saving it on the database by calling this function: exports.saveStat = functions.https.onCall((data, context) => { const currentDate = new Date(); data.date = currentDate; return db.collection(\"stats\") .add(data) .then(function(docRef) { return {\"result\": \"job done\", \"status\": 204}; }) .catch(function(error) { console.error(\"Error adding document: \", error); return {\"error\": error, \"status\": 500}; }); }); Basically, you call it from the client, and sent an object as parameter, this object should keep the following structure: stat = { event: 'the name of the stat', metadata: {...}, userId: 'a user id', } On the metadata object you can store pretty much anything, is just complementary information to the stat itself. Amazon SES The integration with Amazon SES is pretty simple, we set a trigger on the comments collection that is activated when a new documment is done on that collection: exports.newThreadEmailNotification = functions.firestore .document('comments/{commentId}') .onCreate(newThreadEmailNotification); The function called on the trigger is newThreadEmailNotification On: ./funtions/amazonSESFunctions module.exports = newThreadEmailNotification = (doc, context) => { const commentData = doc.data(); let subject = 'The Ironhacks Platform - There is a new comment on a topic you commented! check it out!' commentData.id = doc.id; if (commentData.forumId) { subject = 'The Ironhacks Platform - There is a new topic on the forum! check it out!' } const params = { Destination: { ToAddresses: [ 'example@example.com', ], }, Message: { Body: { Html: { Charset: 'UTF-8', Data: forumActivityTemplate .replace('[topic-title]', 'a title') .replace('[comment-body]', commentData.body) .replace('[thread-id]', commentData.threadID), }, Text: { Charset: 'UTF-8', Data: ` The Ironhacks <Platform></Platform> Hey! there is a new [item-type] posted on the forum! check it out! ${commentData.title} ${commentData.body} https://ironhacks.com/forum/thread/${commentData.id} This is an automatic email, do not reply. `, }, }, Subject: { Charset: 'UTF-8', Data: subject, }, }, Source: 'RCODI <researchopendigitalinnovation@gmail.com>', ReplyToAddresses: [ 'researchopendigitalinnovation@gmail.com', ], }; const sendPromise = new AWS.SES({ apiVersion: '2010-12-01', }).sendEmail(params).promise(); return sendPromise.then((data) => { console.log(`Forum activity email sent ${data.MessageId}`); return true; }).catch((error) => { console.error('Forum activity email not sent', error, error.stack); }); };","title":"Usage"},{"location":"Cloud-Api/usage/#github-api","text":"commitToGitHub createGitHubRepo The flow here is quite simple, we a user creates a project, create that project in two different places: The user\u2019s firebase storage folder and the GitHub organization specified on the initialization section. The user will query the Firebase storage when using the platform, so we always store the latest version of the user project there. However, for the judger to work, we ask the user to \u201cpush\u201d the version that is going to be evaluated. This \u201cpush\u201d actually pushes the files to the GitHub repo. So the judger can retrieve them from GitHub. Keep in mind that this is transparent for the user. Github Configuration const github = require(\"octonode\"); const githubPersonalAccessToken = process.env.GITHUB_ACCESS_TOKEN; const client = github.client(githubPersonalAccessToken); const ghme = client.me(); const ghorg = client.org(\"UNALIronHacks\"); module.exports = { github: github, client: client, me: ghme, org: ghorg, }; Let\u2019s start by the GitHub repository creation:","title":"GitHub API"},{"location":"Cloud-Api/usage/#creategithubrepo","text":"Parameters: const newRepoConfig = { name: projectName, description: 'UNAL-ironhacks-spring-2019', private: true, auto_init: true, } exports.createGitHubRepo = functions.https.onCall(async (data, context) => { try { const result = await ghorg.repoAsync(data); return result; } catch(err) { return {message: 'Error', error: err, status: 500}; } }) This function is really simple, is just a call to the Octonode library (check their docs ) to create a new empty repo. Please refer to the Octonode docs to understand how ghrepo.contentsAsync , ghrepo.updateContentsAsync and ghrepo.createContentsAsync works.","title":"createGithubRepo"},{"location":"Cloud-Api/usage/#committogithub","text":"Main function that submits the committed files to the GitHub API const commitToGitHub = functions.https.onCall(async (data, context) => { const ghrepo = gh.client.repo(\"UNALIronHacks/\" + data.name); const { commitMessage, files } = data; const result = await commitChanges(commitMessage, files, ghrepo); return result; });","title":"commitToGitHub"},{"location":"Cloud-Api/usage/#project-editor","text":"previewWebServer","title":"Project Editor"},{"location":"Cloud-Api/usage/#account-management","text":"registerUser","title":"Account Management"},{"location":"Cloud-Api/usage/#utilities","text":"getPhaseResults getTaskDoc saveLikedCompetitors saveStat","title":"Utilities"},{"location":"Cloud-Api/usage/#amazon-ses-forum","text":"newThreadEmailNotification admin.initializeApp({ credential: admin.credential.cert(serviceAccount), databaseURL: functions.config().database.url }); Besides import the libraries required (we will address them on the fuctions in where they are used, if needed), there are some importants things you should check: const newThreadEmailNotification = require('./amazonSESfunctions'); The email functionality is in it own js file, and we import them here just to export it amogn the bundle. (We will address it at the end) const serviceAccount = require('./service-account.json'); Here we import our Firebase project keys from a local file, remember, you should not upload this file to the repository. And just after that, we initialized the Firebase admin library: admin.initializeApp({ credential: admin.credential.cert(serviceAccount), databaseURL: functions.config().database.url }); Notice how we access to the env variables in order to get the database URL. Here we catch the personal key from the env variables, then we use it to create the instance of github octonode. const githubPersonalAccessToken = functions.config().githubapi.personalkey; And then we create the \u201cuser\u201d object and also select the organization on which we will create the repositories of the projects. Remember that this have to be a PRO user and a PRO organization in order to be able to create private repos. (Please check the Octonode docs if you feel rusty here); in this case the organization is called \u201cUNALIronhacks\u201d, this was the one we used back then, you should put your own one there. const ghme = client.me(); const ghorg = client.org('UNALIronHacks');","title":"Amazon SES &amp; Forum"},{"location":"Cloud-Api/usage/#registration-process","text":"The first group of functions is related with the registration process of an user and is composed by two functions: exports.registerUser = functions.https.onCall((data, context) => {...}) const getNewParticipantForumId = (hackId, userId) => {...} As you can see, only one function is exported, registerUser . getPartipantForumId is and utility used by the first one.","title":"Registration Process"},{"location":"Cloud-Api/usage/#registeruserhackid","text":"On ./functions/index.js Parameters: { \"hackId\": \"hackId\"} hackId is the id from a hack documment on the database. exports.registerUser = functions.https.onCall((data, context) => { return db.collection(\"adminHackData\") .doc(data.hackId) .set({ registeredUsers: admin.firestore.FieldValue.arrayUnion(context.auth.uid) }, {merge: true}) .then((result) => { return getNewParticipantForumId(data.hackId, context.auth.uid) .then((forum) => { return db.collection('users') .doc(context.auth.uid) .set({ hacks: admin.firestore.FieldValue.arrayUnion(data.hackId), forums: forum, }, {merge: true}) .then((result) => { return {message: 'success', status: 200}; }) .catch(error => { return {message: error, status: 500}; }) }) .catch(error => { return {message: error, status: 500}; }) }) .catch(error => { return {message: error, status: 500}; }) }); This function will retrieve the hack data corresponding with the hackId sended as parameter from the adminHackData colletion, it will add the userID to the registeredUsers array and update the hack document. Then, it will ask for the forumID the user was register on and will update the user\u2019s documment, adding the hackID and the forumID to it.","title":"registerUser(hackID)"},{"location":"Cloud-Api/usage/#getnewparticipantforumidhackid-userid","text":"On ./functions/index.js Parameters: hackID : String userID : String const getNewParticipantForumId = (hackId, userId) => { return db.collection(\"forums\") .where('hack', '==', hackId) .get() .then((querySnapshot) => { let selectedForum; let forumParticipants = -1; querySnapshot.forEach((doc) => { const legth = Object.keys(doc.data().participants) if(forumParticipants === -1){ selectedForum = doc; forumParticipants = Object.keys(doc.data().participants); }else if(Object.keys(doc.data().participants).length < forumParticipants.length){ selectedForum = doc; forumParticipants = Object.keys(doc.data().participants); } }); return db.collection('forums').doc(selectedForum.id) .set({participants: {[userId]: `Hacker ${forumParticipants.length + 1}`}}, {merge: true}) .then(() => { const forum = {}; forum[hackId] = {id: selectedForum.id}; return forum; }) .catch(error => { return {message: error, status: 500}; }) }).catch(error => { return {message: error, status: 500}; }) } This function will search into the formus of a given hack (hackID) the one which have the less participants registered on, then it will register the new participant (userID) on it and will return the forum id.","title":"getNewParticipantForumId(hackId, userId)"},{"location":"Cloud-Api/usage/#project-editor_1","text":"Now we are going to describe the function related with the project editor: exports.previewWebServer = functions.https.onRequest((req, res) => {...}) Although you could say that the Github API are also related, for the sake of consistency, we are going to separate the thirdh party ones from this group. One of the biggest needs to the platform is to be able to preview the mockup that is being developed by a participant. Basically, to have a web server. However, What the platform tryes to do here is to mimik the behaviour of a web server, using only cloud functions. Even if a first glance it looks like an over engineered solution, the idea here is to have the less amount of compoenents posible and create a platform easy to use.","title":"Project Editor"},{"location":"Cloud-Api/usage/#preview-aka-web-server","text":"The preview system relies on to key components, the previewWebServer function and the rewrite is defined on the config file: On ./firebase.json ... \"rewrites\": [ { \"source\": \"/preview/**\", \"function\": \"previewWebServer\" }, { \"source\": \"**\", \"destination\": \"/index.html\" } ] }, ... First, let\u2019s look the config file: We are redirecting everything that go to the preview url to call the previewWebServer function, this allow the function to be triggered whenever a file for a given is requested. Let\u2019s check the function itself: exports.previewWebServer = functions.https.onRequest((req, res) => { const filePathStorage = req.originalUrl.replace('/preview', ''); const fileName = path.basename(filePathStorage); const tempPath = path.join(os.tmpdir(), `${fileName}`); return storage .bucket(functions.config().database.bucket) .file(filePathStorage) .download({ destination: tempPath, }).then(() => { res.sendFile(tempPath, (err) => { if (err) { return res.end(); }else{ return res.end(); } }); }).catch((error) => { console.error(error.message); if(error.message === 'Not Found') { console.error('File not found', filePathStorage); return res.status(404).send('File not found on storage'); }else{ return res.status(500).send(error.message); } }) }); We call this function directly from the browser (since the idea is to replicate a web server), and the structure of the URL is the following: const projectURL = `${Constants.cloudFunctionsProdEndPoint}/previewWebServer/${this.state.user.uid}/${this.state.projectName}/index.html`; The Constants.cloudFunctionsProdEnd is the endpoint of your firebase cloud functions project. This function will retrieve the resource requested on the path, in this case, we allways start by de index.html. Once the index.html is loaded by the browser, it will call again the same function in order to load additional assets, for example, a javascript file. Since we rewrite de function, everytime the browser request other file, like js/main.js it will be redirected to the previewWebServer function, and it will retrieve the file. Keep in mind that this function retrieve the files from the Firebase storage service.","title":"Preview (AKA Web Server)"},{"location":"Cloud-Api/usage/#experiment-related-functions","text":"Since the main idea of the platform is to create specific conditions related with the experiment that is being done, the platform exposes 4 particular functions that will help you to do that: exports.getTaskDoc = functions.https.onCall((data, context) => {...} exports.saveStat = functions.https.onCall((data, context) => {...} exports.getPhaseResults = functions.https.onCall((data, context) => {...} exports.saveLikedCompetitors = functions.https.onCall((data, context) => {...} Let\u2019s start by the most basic:","title":"Experiment related functions"},{"location":"Cloud-Api/usage/#gettaskdoc","text":"This function return the Task document, this is the documment that contains the challenge or problem the participants of a hack will face. Keep in mind that the document will only be served if the publish date already pass. Also keep in mind that the content of the file is encode in base64. exports.getTaskDoc = functions.https.onCall((data, context) => { const currentDate = new Date(); return db.collection(\"adminHackData\") .doc(data.hackId) .get() .then((doc) => { const seconds = doc.data().task.releaseDate._seconds const nanoseconds = doc.data().task.releaseDate._nanoseconds const releaseDate = new admin.firestore.Timestamp(seconds, nanoseconds).toDate(); if(releaseDate < currentDate){ return {task: doc.data().task.doc}; }else { return {error: 'To early', status: 500}; } }) .catch(error => { console.error(error); return {message: error, status: 500}; }) });","title":"getTaskDoc"},{"location":"Cloud-Api/usage/#savestat","text":"The platform allows you to collect stats, you can pretty much collect every single interaction and saving it on the database by calling this function: exports.saveStat = functions.https.onCall((data, context) => { const currentDate = new Date(); data.date = currentDate; return db.collection(\"stats\") .add(data) .then(function(docRef) { return {\"result\": \"job done\", \"status\": 204}; }) .catch(function(error) { console.error(\"Error adding document: \", error); return {\"error\": error, \"status\": 500}; }); }); Basically, you call it from the client, and sent an object as parameter, this object should keep the following structure: stat = { event: 'the name of the stat', metadata: {...}, userId: 'a user id', } On the metadata object you can store pretty much anything, is just complementary information to the stat itself.","title":"saveStat"},{"location":"Cloud-Api/usage/#amazon-ses","text":"The integration with Amazon SES is pretty simple, we set a trigger on the comments collection that is activated when a new documment is done on that collection: exports.newThreadEmailNotification = functions.firestore .document('comments/{commentId}') .onCreate(newThreadEmailNotification); The function called on the trigger is newThreadEmailNotification On: ./funtions/amazonSESFunctions module.exports = newThreadEmailNotification = (doc, context) => { const commentData = doc.data(); let subject = 'The Ironhacks Platform - There is a new comment on a topic you commented! check it out!' commentData.id = doc.id; if (commentData.forumId) { subject = 'The Ironhacks Platform - There is a new topic on the forum! check it out!' } const params = { Destination: { ToAddresses: [ 'example@example.com', ], }, Message: { Body: { Html: { Charset: 'UTF-8', Data: forumActivityTemplate .replace('[topic-title]', 'a title') .replace('[comment-body]', commentData.body) .replace('[thread-id]', commentData.threadID), }, Text: { Charset: 'UTF-8', Data: ` The Ironhacks <Platform></Platform> Hey! there is a new [item-type] posted on the forum! check it out! ${commentData.title} ${commentData.body} https://ironhacks.com/forum/thread/${commentData.id} This is an automatic email, do not reply. `, }, }, Subject: { Charset: 'UTF-8', Data: subject, }, }, Source: 'RCODI <researchopendigitalinnovation@gmail.com>', ReplyToAddresses: [ 'researchopendigitalinnovation@gmail.com', ], }; const sendPromise = new AWS.SES({ apiVersion: '2010-12-01', }).sendEmail(params).promise(); return sendPromise.then((data) => { console.log(`Forum activity email sent ${data.MessageId}`); return true; }).catch((error) => { console.error('Forum activity email not sent', error, error.stack); }); };","title":"Amazon SES"},{"location":"Developer-Documentation/overview/","text":"About MkDocs Documentation is generated using Markdown with MkDocs and the Read the Docs style theme. Docs files can be hosted on GitHub Pages in a separate repository or can exist as a subfolder of an individual project, or can live on it\u2019s own gh-pages branch within a repository. GitHub will automattically update the documentation each time files under these locations are changed with a new commit. For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Options mkdocs build \u2013clean Project layout mkdocs.yml # The configuration file. docs/ - index.md # The documentation homepage. - sectionA.md # Other markdown pages ... subfolder/ # Creates a new section with the title of the folder - index.md - sectionB.md Setup mkdocs.yml theme: 'readthedocs' Config List of all mkdocs config options: mkdocs.org/user-guide/configuration Extensions Install with pip install <EXTENSION_NAME> Currently Using: smarty extra toc meta tables fenced_code markdown_checklist.extension List of Markdown Extensions github.com/Python-Markdown/markdown/wiki/Third-Party-Extensions","title":"Overview"},{"location":"Developer-Documentation/overview/#about-mkdocs","text":"Documentation is generated using Markdown with MkDocs and the Read the Docs style theme. Docs files can be hosted on GitHub Pages in a separate repository or can exist as a subfolder of an individual project, or can live on it\u2019s own gh-pages branch within a repository. GitHub will automattically update the documentation each time files under these locations are changed with a new commit. For full documentation visit mkdocs.org .","title":"About MkDocs"},{"location":"Developer-Documentation/overview/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Options mkdocs build \u2013clean","title":"Commands"},{"location":"Developer-Documentation/overview/#project-layout","text":"mkdocs.yml # The configuration file. docs/ - index.md # The documentation homepage. - sectionA.md # Other markdown pages ... subfolder/ # Creates a new section with the title of the folder - index.md - sectionB.md","title":"Project layout"},{"location":"Developer-Documentation/overview/#setup","text":"mkdocs.yml theme: 'readthedocs'","title":"Setup"},{"location":"Developer-Documentation/overview/#config","text":"List of all mkdocs config options: mkdocs.org/user-guide/configuration","title":"Config"},{"location":"Developer-Documentation/overview/#extensions","text":"Install with pip install <EXTENSION_NAME> Currently Using: smarty extra toc meta tables fenced_code markdown_checklist.extension List of Markdown Extensions github.com/Python-Markdown/markdown/wiki/Third-Party-Extensions","title":"Extensions"},{"location":"Developer-Documentation/references/","text":"References Purdue-IronHacks-Fall-2018-Tutorials Welcome to the Purdue IronHacks - Fall 2018! Welcome to RCODI fellowship Fall 2018! These pages aim to introduce you to various technologies that will be required as part of this programming skills to develop. Session 1 - 27/10/2018 02:00 PM An official tutorial for HTML Tutorial \u2013 w3 school tutorial for html Basic HTML video and sample code 1 HTML Video 1 \u2013 html video 1 on social coding platform HTML Sample Code 1 \u2013 html code 1 on social coding platform Basic HTML video and sample code 2 HTML Video 2 \u2013 html video 2 on social coding platform HTML Sample Code 2 \u2013 html code 2 on social coding platform Basic HTML video and sample code 3 HTML Video 3 \u2013 html video 3 on social coding platform HTML Sample Code 3 \u2013 html code 3 on social coding platform An official tutorial for CSS Tutorial \u2013 css tutorial on w3 school Official website for Bootstrap Bootstrap 1 \u2013 bootstrap tutorial Basic BOOTSTRAP video and sample code version Boostrap Video 1 \u2013 boostrap video on social coding editor Boostrap Sample Code 1 \u2013 boostrap codes on social coding editor Additional Videos and links Sample Project \u2013 A demo project for HTML and CSS using socila coding platform HTML & CSS 1 \u2013 Link to video 1 HTML & CSS 2 Link to video 2 HTML and CSS HTML and CSS example here Video tutorial - Introduction to Bootstrap: Bootstrap Source code - Source code used in the video. Additional resources: Bootstrap official website Bootstrap example Official HTML documentation - Mozilla Developer Network HTML docs - MDN Official CSS documentation - Mozilla Developer Network HTML docs - MDN HTML Tutorial - w3schools.com w3schools - HTML CSS Tutorial - w3schools.com w3schools - CSS Quiz session 1: Quiz - HTML & CSS Quiz - Bootstrap These quizzes are MANDATORY. They must finish it BEFORE November 1, 2018. Session 2 - 03/11/2018 02:00 PM Javascript and jQuery An official tutorial for Javascript JS Tutorial \u2013 javascript tutorial on w3 school Javascript Video 1 \u2013 javascript video 1 on social coding platform Javascript Training Code \u2013 javascript code from the training session Javascript Code 1 \u2013 javascript code 1 on social coding platform Javascript Video 2 \u2013 javascript video 2 on social coding platform Javascript Code 2 \u2013 javascript code 2 on social coding platform Javascript In Class Tutorial \u2013 javascript in class tutorial An official tutorial for jQuery jQuery Tutorial \u2013w3 school tutorial for jQuery Additional Projects link and Videos (if you want to practice more) JavaScript 1 \u2013Link to Javascript video 1 JavaScript 2 \u2013Link to Javascript video 2 JavaScript 3 \u2013Link to Javascript video 3 jQuery 1 \u2013 Link to jQuery video 1 jQuery 2 \u2013 Link to jQuery video 2 jQuery 3 \u2013 Link to jQuery video 3 Additional resources: JS official documentation - Mozilla Developer Network Javascript Docs Javascript Docs Video tutorial - Introduction to Javascript and jQuery Official jQuery documentation jQuery Docs Javascript tutorial - w3schools.com w3schools - Javascript Quiz session 2: Quiz - Javascript This quiz is MANDATORY. Tutorial D3.js D3 Tutorial 1 \u2013Official Tutorial for d3.js library D3 Video 2 \u2013 Our own d3 video 2, using social coding platform D3 Training Repository \u2013 Our own d3 code from the repository used on the training D3 In Class Tutorial \u2013 Our own d3 in class tutorial helpd on October 25&26th D3 In Class Sample Codes \u2013 d3 in class sample codes for tutorial in class on October 25th26th Official Website of d3 library D3.js \u2013Official site for d3.js library D3.js - Introduction to D3.js Visualize JSON data Additional Projects link and videos (if you want to practice more) Sample Project \u2013 Another simple project for d3 specifically developed for IronHacks (not on social coding platform d3.js 1 \u2013 Code for the project above d3.js 2 \u2013 Code for the project above d3.js 3 \u2013 Code for the project above d3.js 4 \u2013 Code for the project above Additional resources: Web oficial D3.js Quiz - D3.js This quiz is MANDATORY. Session 3 - 10/11/2018 02:00 PM Presentations to learn about (1) design elements, (2) design principles, (3) usability heuristics design elements \u2013Learn about design elements design principles \u2013 Learn about design principles usability heuristics \u2013 Learn about usability heuristics Design principles Support material: Video about usability 1 (https://www.youtube.com/watch?v=Rlip6LSp5iA) Video about usability 2 (https://www.youtube.com/watch?v=rT4sqdtvoL8) Video about usability 3","title":"References"},{"location":"Developer-Documentation/references/#references","text":"","title":"References"},{"location":"Developer-Documentation/references/#purdue-ironhacks-fall-2018-tutorials","text":"Welcome to the Purdue IronHacks - Fall 2018! Welcome to RCODI fellowship Fall 2018! These pages aim to introduce you to various technologies that will be required as part of this programming skills to develop.","title":"Purdue-IronHacks-Fall-2018-Tutorials"},{"location":"Developer-Documentation/references/#session-1-27102018-0200-pm","text":"","title":"Session 1 - 27/10/2018 02:00 PM"},{"location":"Developer-Documentation/references/#an-official-tutorial-for-html","text":"Tutorial \u2013 w3 school tutorial for html","title":"An official tutorial for HTML"},{"location":"Developer-Documentation/references/#basic-html-video-and-sample-code-1","text":"HTML Video 1 \u2013 html video 1 on social coding platform HTML Sample Code 1 \u2013 html code 1 on social coding platform","title":"Basic HTML video and sample code 1"},{"location":"Developer-Documentation/references/#basic-html-video-and-sample-code-2","text":"HTML Video 2 \u2013 html video 2 on social coding platform HTML Sample Code 2 \u2013 html code 2 on social coding platform","title":"Basic HTML video and sample code 2"},{"location":"Developer-Documentation/references/#basic-html-video-and-sample-code-3","text":"HTML Video 3 \u2013 html video 3 on social coding platform HTML Sample Code 3 \u2013 html code 3 on social coding platform","title":"Basic HTML video and sample code 3"},{"location":"Developer-Documentation/references/#an-official-tutorial-for-css","text":"Tutorial \u2013 css tutorial on w3 school","title":"An official tutorial for CSS"},{"location":"Developer-Documentation/references/#official-website-for-bootstrap","text":"Bootstrap 1 \u2013 bootstrap tutorial","title":"Official website for Bootstrap"},{"location":"Developer-Documentation/references/#basic-bootstrap-video-and-sample-code-version","text":"Boostrap Video 1 \u2013 boostrap video on social coding editor Boostrap Sample Code 1 \u2013 boostrap codes on social coding editor","title":"Basic BOOTSTRAP video and sample code version"},{"location":"Developer-Documentation/references/#additional-videos-and-links","text":"Sample Project \u2013 A demo project for HTML and CSS using socila coding platform HTML & CSS 1 \u2013 Link to video 1 HTML & CSS 2 Link to video 2 HTML and CSS HTML and CSS example here","title":"Additional Videos and  links"},{"location":"Developer-Documentation/references/#video-tutorial-introduction-to-bootstrap","text":"Bootstrap Source code - Source code used in the video. Additional resources: Bootstrap official website Bootstrap example","title":"Video tutorial - Introduction to Bootstrap:"},{"location":"Developer-Documentation/references/#official-html-documentation-mozilla-developer-network","text":"HTML docs - MDN","title":"Official HTML documentation - Mozilla Developer Network"},{"location":"Developer-Documentation/references/#official-css-documentation-mozilla-developer-network","text":"HTML docs - MDN","title":"Official CSS documentation - Mozilla Developer Network"},{"location":"Developer-Documentation/references/#html-tutorial-w3schoolscom","text":"w3schools - HTML","title":"HTML Tutorial - w3schools.com"},{"location":"Developer-Documentation/references/#css-tutorial-w3schoolscom","text":"w3schools - CSS","title":"CSS Tutorial - w3schools.com"},{"location":"Developer-Documentation/references/#quiz-session-1","text":"Quiz - HTML & CSS Quiz - Bootstrap These quizzes are MANDATORY. They must finish it BEFORE November 1, 2018.","title":"Quiz session 1:"},{"location":"Developer-Documentation/references/#session-2-03112018-0200-pm","text":"","title":"Session 2 - 03/11/2018 02:00 PM"},{"location":"Developer-Documentation/references/#javascript-and-jquery","text":"","title":"Javascript and jQuery"},{"location":"Developer-Documentation/references/#an-official-tutorial-for-javascript","text":"JS Tutorial \u2013 javascript tutorial on w3 school Javascript Video 1 \u2013 javascript video 1 on social coding platform Javascript Training Code \u2013 javascript code from the training session Javascript Code 1 \u2013 javascript code 1 on social coding platform Javascript Video 2 \u2013 javascript video 2 on social coding platform Javascript Code 2 \u2013 javascript code 2 on social coding platform Javascript In Class Tutorial \u2013 javascript in class tutorial","title":"An official tutorial for Javascript"},{"location":"Developer-Documentation/references/#an-official-tutorial-for-jquery","text":"jQuery Tutorial \u2013w3 school tutorial for jQuery","title":"An official tutorial for jQuery"},{"location":"Developer-Documentation/references/#additional-projects-link-and-videos-if-you-want-to-practice-more","text":"JavaScript 1 \u2013Link to Javascript video 1 JavaScript 2 \u2013Link to Javascript video 2 JavaScript 3 \u2013Link to Javascript video 3 jQuery 1 \u2013 Link to jQuery video 1 jQuery 2 \u2013 Link to jQuery video 2 jQuery 3 \u2013 Link to jQuery video 3","title":"Additional Projects link and Videos (if you want to practice more)"},{"location":"Developer-Documentation/references/#additional-resources","text":"","title":"Additional resources:"},{"location":"Developer-Documentation/references/#js-official-documentation-mozilla-developer-network","text":"Javascript Docs Javascript Docs Video tutorial - Introduction to Javascript and jQuery Official jQuery documentation jQuery Docs","title":"JS official documentation - Mozilla Developer Network"},{"location":"Developer-Documentation/references/#javascript-tutorial-w3schoolscom","text":"w3schools - Javascript Quiz session 2: Quiz - Javascript This quiz is MANDATORY.","title":"Javascript tutorial - w3schools.com"},{"location":"Developer-Documentation/references/#tutorial-d3js","text":"D3 Tutorial 1 \u2013Official Tutorial for d3.js library D3 Video 2 \u2013 Our own d3 video 2, using social coding platform D3 Training Repository \u2013 Our own d3 code from the repository used on the training D3 In Class Tutorial \u2013 Our own d3 in class tutorial helpd on October 25&26th D3 In Class Sample Codes \u2013 d3 in class sample codes for tutorial in class on October 25th26th","title":"Tutorial D3.js"},{"location":"Developer-Documentation/references/#official-website-of-d3-library","text":"D3.js \u2013Official site for d3.js library D3.js - Introduction to D3.js Visualize JSON data","title":"Official Website of d3 library"},{"location":"Developer-Documentation/references/#additional-projects-link-and-videos-if-you-want-to-practice-more_1","text":"Sample Project \u2013 Another simple project for d3 specifically developed for IronHacks (not on social coding platform d3.js 1 \u2013 Code for the project above d3.js 2 \u2013 Code for the project above d3.js 3 \u2013 Code for the project above d3.js 4 \u2013 Code for the project above Additional resources: Web oficial D3.js Quiz - D3.js This quiz is MANDATORY.","title":"Additional Projects link and videos (if you want to practice more)"},{"location":"Developer-Documentation/references/#session-3-10112018-0200-pm","text":"","title":"Session 3 - 10/11/2018 02:00 PM"},{"location":"Developer-Documentation/references/#presentations-to-learn-about-1-design-elements-2-design-principles-3-usability-heuristics","text":"design elements \u2013Learn about design elements design principles \u2013 Learn about design principles usability heuristics \u2013 Learn about usability heuristics Design principles","title":"Presentations to learn about (1) design elements, (2) design principles, (3) usability heuristics"},{"location":"Developer-Documentation/references/#support-material","text":"Video about usability 1 (https://www.youtube.com/watch?v=Rlip6LSp5iA) Video about usability 2 (https://www.youtube.com/watch?v=rT4sqdtvoL8) Video about usability 3","title":"Support material:"},{"location":"Platform-Documentation/admin/","text":"Admin","title":"Admin"},{"location":"Platform-Documentation/admin/#admin","text":"","title":"Admin"},{"location":"Platform-Documentation/hacks/","text":"Hacks","title":"Hacks"},{"location":"Platform-Documentation/hacks/#hacks","text":"","title":"Hacks"},{"location":"Platform-Documentation/metrics/","text":"Platform Metrics Event List DEFAULT EVENTS app_load AUTHENTICATION & REGISTRATION EVENTS user_signup user_login user_logout GENERAL PLATFORM EVENTS download_file update_profile register_hack HACK EVENTS These events require user registration Content Viewing Events view_calendar view_notebook view_overview view_task view_post view_profile view_rules view_tutorial User Interaction Events launch_hub open_survey submit_comment user_submission Results Dashboard Events (DURING HACK) results_section_view results_phase_view results_notebook_opened results_summary_expanded ADMIN ONLY submit_post edit_forum_post overview-updated results-published results-unpublished results-updated rules-updated tutorial-created task-created task-published task-unpublished task-updated","title":"Platform Metrics"},{"location":"Platform-Documentation/metrics/#platform-metrics","text":"","title":"Platform Metrics"},{"location":"Platform-Documentation/metrics/#event-list","text":"","title":"Event List"},{"location":"Platform-Documentation/metrics/#default-events","text":"app_load","title":"DEFAULT EVENTS"},{"location":"Platform-Documentation/metrics/#authentication-registration-events","text":"user_signup user_login user_logout","title":"AUTHENTICATION &amp; REGISTRATION EVENTS"},{"location":"Platform-Documentation/metrics/#general-platform-events","text":"download_file update_profile register_hack","title":"GENERAL PLATFORM EVENTS"},{"location":"Platform-Documentation/metrics/#hack-events","text":"These events require user registration","title":"HACK EVENTS"},{"location":"Platform-Documentation/metrics/#content-viewing-events","text":"view_calendar view_notebook view_overview view_task view_post view_profile view_rules view_tutorial","title":"Content Viewing Events"},{"location":"Platform-Documentation/metrics/#user-interaction-events","text":"launch_hub open_survey submit_comment user_submission","title":"User Interaction Events"},{"location":"Platform-Documentation/metrics/#results-dashboard-events-during-hack","text":"results_section_view results_phase_view results_notebook_opened results_summary_expanded","title":"Results Dashboard Events (DURING HACK)"},{"location":"Platform-Documentation/metrics/#admin-only","text":"submit_post edit_forum_post overview-updated results-published results-unpublished results-updated rules-updated tutorial-created task-created task-published task-unpublished task-updated","title":"ADMIN ONLY"}]}